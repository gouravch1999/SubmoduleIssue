/****************************************************************************
 * COPYRIGHT VITESCO TECHNOLOGIES GROUP AG (EXCLUSIVE RIGHTS) 
 * Confidential
 * 
 * The reproduction, transmission or use of this document or its
 * contents is not permitted without express written authority.
 * Offenders will be liable for damages. All rights, including rights
 * created by patent grant or registration of a utility model or design,
 * are reserved.
 *---------------------------------------------------------------------------
 * 
 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 * !!! This file is generated by Signal Mapper (SIMA) Code-Generator !!!
 * !!! Do NOT modify this file manually                            !!!
 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 * 
 * Purpose:    PL Hook Implementation
 * 
 * Processor:  independent
 * Tool chain: 
 *    CG-Version:        6.2.0
 *    Schema-Version:    1.18.0
 *    Generation-Date:   29.08.2024  16:59:16  
 *    Generated by user: uiv00534
 * Filename:   $Workfile$
 * Revision:   $Revision: 1.1 $
 * Author:     $Author: Zhang Yi (uiv00534) (uiv00534) $
 * Date:       $Date: 2024/09/03 03:20:51CEST $
 * Changes:    $Log: ipl_hook_tx_sec.c  $
 * Changes:    Revision 1.1 2024/09/03 03:20:51CEST Zhang Yi (uiv00534) (uiv00534) 
 * Changes:    Initial revision
 * Changes:    Member added to project /ES/FS/0G/H0D/0A/bsw/intc/intc_sigcv_mc1/i/project.pj
 * 
****************************************************************************/
/*lint -esym(750,IPL_HOOK_TX_SEC_C) */
#define IPL_HOOK_TX_SEC_C
#include <intc_sigcv_mc1_im.h>


#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduSec_EDU_activeDischFeatEn
/*lint  -efile(451,ipl_hook_tx_sec_mcr.h) */
#include <ipl_hook_tx_sec_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduSec_EDU_activeDischFeatEn) */
ICS_PL_RETURN_TYPE PL_Cvt_EduSec_EDU_activeDischFeatEn(void)
{
    /* Conversion for TX-Bus-Signal 'EduSec_EDU_activeDischFeatEn' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_FLAG bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: Pl_AcvDchaSts(intc_sigcv_tx_sec) */
    /*     Category, Type, Interface: TEXT, ICS_PL_FLAG, VAR */
    /*     Desc: Active discharge enabled */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     FALSE [0x0; 0x0] */
    /*     TRUE [0x1; 0x1] */
    /*     Variable-Name: Pl_AcvDchaSts */
    
    /* Destination-Signal Description: */
    /*     Name: EduSec_EDU_activeDischFeatEn(intc_sigcv_tx_sec) */
    /*     Category, Type, length, Interface: TEXT, ICS_PL_FLAG, 1 bits, API */
    /*     Desc: Inverter Active Discharge Feature Enabled" */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     FALSE [0x0; 0x0] */
    /*     TRUE [0x1; 0x1] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_sec_Mapping_EDU2_activeDischFeatEn */
    /*     Processing: UNCONDITIONAL */
    /*     Text Mapping */
    /*     SRC -> DST */
    /*     FALSE[0x0] -> FALSE[0x0] */
    /*     TRUE[0x1] -> TRUE[0x1] */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    if(GET_Pl_AcvDchaSts() == ICS_PL_FALSE)
    {
        /* Map SRC-Value 'FALSE' to DST-Value 'FALSE' */
        bus_cpy = ICS_PL_FALSE;
    }
    else
    {
        /* Map SRC-Value 'TRUE' to DST-Value 'TRUE' */
        bus_cpy = ICS_PL_TRUE;
    }
    /* Copy temporary-dst-container to DST */
    if(WRITE_SIGNAL_DATA_API(EduSec_EDU_activeDischFeatEn, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduSec_EDU_clutchState
/*lint  -efile(451,ipl_hook_tx_sec_mcr.h) */
#include <ipl_hook_tx_sec_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduSec_EDU_clutchState) */
ICS_PL_RETURN_TYPE PL_Cvt_EduSec_EDU_clutchState(void)
{
    /* Conversion for TX-Bus-Signal 'EduSec_EDU_clutchState' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U8 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: Pl_CluAxleSt(intc_sigcv_tx_sec) */
    /*     Category, Type, Interface: TEXT, ICS_PL_U8, VAR */
    /*     Desc: Operational state of electrical machine clutch */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     INI [0x0; 0x0] */
    /*     DISCNCT [0x1; 0x1] */
    /*     TRAN [0x2; 0x2] */
    /*     CNCT [0x3; 0x3] */
    /*     ERR [0x4; 0x4] */
    /*     Variable-Name: Pl_CluAxleSt */
    
    /* Destination-Signal Description: */
    /*     Name: EduSec_EDU_clutchState(intc_sigcv_tx_sec) */
    /*     Category, Type, length, Interface: TEXT, ICS_PL_U8, 3 bits, API */
    /*     Desc: Clutch2 Control Status" */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     IN_TRANSITION [0x6; 0x6] */
    /*     FAULT [0x5; 0x5] */
    /*     ENGAGING [0x4; 0x4] */
    /*     ENGAGED [0x3; 0x3] */
    /*     DISENGAGING [0x2; 0x2] */
    /*     DISENGAGED [0x1; 0x1] */
    /*     UNKNOWN [0x0; 0x0] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_sec_Mapping_EDU2_clutchState */
    /*     Processing: BYPASS */
    /*     Bypass-Callout: ByPass_EDU_clutchState */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Init temporary-dst-container */
    bus_cpy = 0U;
    
    /* Bypass PL */
    if(ByPass_EDU_clutchState(GET_Pl_CluAxleSt(), &bus_cpy) == ICS_PL_TRUE)
    {
        /* Copy temporary-dst-container to DST */
        if(WRITE_SIGNAL_DATA_API(EduSec_EDU_clutchState, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
        {
            tmp_return_value = ICS_PL_FALSE;
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduSec_EDU_comStatusPrimary
/*lint  -efile(451,ipl_hook_tx_sec_mcr.h) */
#include <ipl_hook_tx_sec_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduSec_EDU_comStatusPrimary) */
ICS_PL_RETURN_TYPE PL_Cvt_EduSec_EDU_comStatusPrimary(void)
{
    /* Conversion for TX-Bus-Signal 'EduSec_EDU_comStatusPrimary' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U8 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: u8ComStatusPrimary(intc_sigcv_tx_sec) */
    /*     Category, Type, Interface: TEXT, ICS_PL_U8, VAR */
    /*     State(s): [0x0...0x0] */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     UNAVAILABLE [0x0; 0x0] */
    /*     BACKUP [0x1; 0x1] */
    /*     ACTIVE [0x2; 0x2] */
    /*     Variable-Name: u8ComStatusPrimary */
    
    /* Destination-Signal Description: */
    /*     Name: EduSec_EDU_comStatusPrimary(intc_sigcv_tx_sec) */
    /*     Category, Type, length, Interface: TEXT, ICS_PL_U8, 2 bits, API */
    /*     Desc:  */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     ACTIVE [0x2; 0x2] */
    /*     BACKUP [0x1; 0x1] */
    /*     UNAVAILABLE [0x0; 0x0] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_sec_Mapping_EDU2_comStatusPrimary */
    /*     Processing: UNCONDITIONAL */
    /*     Text Mapping */
    /*     SRC -> DST */
    /*     UNAVAILABLE[0x0] -> UNAVAILABLE[0x0] */
    /*     BACKUP[0x1] -> BACKUP[0x1] */
    /*     ACTIVE[0x2] -> ACTIVE[0x2] */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Init temporary-dst-container */
    bus_cpy = 0U;
    if(GET_u8ComStatusPrimary() == 0U)
    {
        /* Map SRC-Value 'UNAVAILABLE' to DST-Value 'UNAVAILABLE' */
        bus_cpy = 0U;
    }
    else if(GET_u8ComStatusPrimary() == 1U)
    {
        /* Map SRC-Value 'BACKUP' to DST-Value 'BACKUP' */
        bus_cpy = 1U;
    }
    else if(GET_u8ComStatusPrimary() == 2U)
    {
        /* Map SRC-Value 'ACTIVE' to DST-Value 'ACTIVE' */
        bus_cpy = 2U;
    }
    else
    {
        /* SRC is not within the valid COD-range => cancel processing */
        tmp_return_value = ICS_PL_FALSE;
    }
    if(tmp_return_value == ICS_PL_TRUE)
    {
        /* Copy temporary-dst-container to DST */
        if(WRITE_SIGNAL_DATA_API(EduSec_EDU_comStatusPrimary, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
        {
            tmp_return_value = ICS_PL_FALSE;
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduSec_EDU_comStatusSecondary
/*lint  -efile(451,ipl_hook_tx_sec_mcr.h) */
#include <ipl_hook_tx_sec_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduSec_EDU_comStatusSecondary) */
ICS_PL_RETURN_TYPE PL_Cvt_EduSec_EDU_comStatusSecondary(void)
{
    /* Conversion for TX-Bus-Signal 'EduSec_EDU_comStatusSecondary' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U8 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: u8ComStatusSecondary(intc_sigcv_tx_sec) */
    /*     Category, Type, Interface: TEXT, ICS_PL_U8, VAR */
    /*     State(s): [0x0...0x0] */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     UNAVAILABLE [0x0; 0x0] */
    /*     BACKUP [0x1; 0x1] */
    /*     ACTIVE [0x2; 0x2] */
    /*     Variable-Name: u8ComStatusSecondary */
    
    /* Destination-Signal Description: */
    /*     Name: EduSec_EDU_comStatusSecondary(intc_sigcv_tx_sec) */
    /*     Category, Type, length, Interface: TEXT, ICS_PL_U8, 2 bits, API */
    /*     Desc:  */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     ACTIVE [0x2; 0x2] */
    /*     BACKUP [0x1; 0x1] */
    /*     UNAVAILABLE [0x0; 0x0] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_sec_Mapping_EDU2_comStatusSecondary */
    /*     Processing: UNCONDITIONAL */
    /*     Text Mapping */
    /*     SRC -> DST */
    /*     UNAVAILABLE[0x0] -> UNAVAILABLE[0x0] */
    /*     BACKUP[0x1] -> BACKUP[0x1] */
    /*     ACTIVE[0x2] -> ACTIVE[0x2] */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Init temporary-dst-container */
    bus_cpy = 0U;
    if(GET_u8ComStatusSecondary() == 0U)
    {
        /* Map SRC-Value 'UNAVAILABLE' to DST-Value 'UNAVAILABLE' */
        bus_cpy = 0U;
    }
    else if(GET_u8ComStatusSecondary() == 1U)
    {
        /* Map SRC-Value 'BACKUP' to DST-Value 'BACKUP' */
        bus_cpy = 1U;
    }
    else if(GET_u8ComStatusSecondary() == 2U)
    {
        /* Map SRC-Value 'ACTIVE' to DST-Value 'ACTIVE' */
        bus_cpy = 2U;
    }
    else
    {
        /* SRC is not within the valid COD-range => cancel processing */
        tmp_return_value = ICS_PL_FALSE;
    }
    if(tmp_return_value == ICS_PL_TRUE)
    {
        /* Copy temporary-dst-container to DST */
        if(WRITE_SIGNAL_DATA_API(EduSec_EDU_comStatusSecondary, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
        {
            tmp_return_value = ICS_PL_FALSE;
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduSec_EDU_currentDc
/*lint  -efile(451,ipl_hook_tx_sec_mcr.h) */
#include <ipl_hook_tx_sec_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduSec_EDU_currentDc) */
ICS_PL_RETURN_TYPE PL_Cvt_EduSec_EDU_currentDc(void)
{
    /* Conversion for TX-Bus-Signal 'EduSec_EDU_currentDc' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_S16 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: Pl_HvDcIEstimd(intc_sigcv_tx_sec) */
    /*     Category, Type, Interface: NUM, ICS_PL_FLOAT, VAR */
    /*     Desc: Filtered DC link current */
    /*     Harmonized Physical Range: [-2048...2047.9375] [PD_A] */
    /*     Original Physical Range: [-2048...2047.9375] [A] */
    /*     Variable-Name: Pl_HvDcIEstimd */
    
    /* Destination-Signal Description: */
    /*     Name: EduSec_EDU_currentDc(intc_sigcv_tx_sec) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_S16, 10 bits, API */
    /*     Desc: Inverter DC Current" */
    /*     Coded Range: [0xFE02...0x1FE] */
    /*     Harmonized Physical Range: [-510...510] [A] */
    /*     Original Physical Range: [-510...510] [A] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_sec_Mapping_EDU2_currentDc */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Init temporary-dst-container */
    bus_cpy = 0;
    /* Range-Check. Potential violation of SRC.COD_LOWER_LIMIT and SRC.COD_UPPER_LIMIT */
    if((GET_Pl_HvDcIEstimd() <= 2047.9375F) && (GET_Pl_HvDcIEstimd() >= -2048.0F))
    {
        /* Limitation Handling. Potential violation of DST.COD_LOWER_LIMIT */
        if(GET_Pl_HvDcIEstimd() >= -510.0F)
        {
            /* Limitation Handling. Potential violation of DST.COD_UPPER_LIMIT */
            if(GET_Pl_HvDcIEstimd() <= 510.0F)
            {
                ICS_PL_FLOAT temp_float = ((ICS_PL_FLOAT)GET_Pl_HvDcIEstimd());
                bus_cpy = (ICS_PL_S16_ICS_PL_FLOAT)(temp_float);
            }
            else
            {
                /* Automatically limit to DST.COD_UPPER_LIMIT */
                bus_cpy = 510;
            }
        }
        else
        {
            /* Automatically limit to DST.COD_LOWER_LIMIT */
            bus_cpy = ((ICS_PL_S16)-510);
        }
    }
    else
    {
        /* SRC is not within the valid COD-range => cancel processing */
        tmp_return_value = ICS_PL_FALSE;
    }
    if(tmp_return_value == ICS_PL_TRUE)
    {
        /* Copy temporary-dst-container to DST */
        if(WRITE_SIGNAL_DATA_API(EduSec_EDU_currentDc, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
        {
            tmp_return_value = ICS_PL_FALSE;
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduSec_EDU_heatPower
/*lint  -efile(451,ipl_hook_tx_sec_mcr.h) */
#include <ipl_hook_tx_sec_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduSec_EDU_heatPower) */
ICS_PL_RETURN_TYPE PL_Cvt_EduSec_EDU_heatPower(void)
{
    /* Conversion for TX-Bus-Signal 'EduSec_EDU_heatPower' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U16 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: Pl_PwrLossElInvt(intc_sigcv_tx_sec) */
    /*     Category, Type, Interface: NUM, ICS_PL_FLOAT, VAR */
    /*     Desc: Electrical power losses from inverter */
    /*     Harmonized Physical Range: [-67108864...67108863.96875] [PD_W] */
    /*     Original Physical Range: [-67108864...67108863.96875] [W] */
    /*     Variable-Name: Pl_PwrLossElInvt */
    
    /* Destination-Signal Description: */
    /*     Name: EduSec_EDU_heatPower(intc_sigcv_tx_sec) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_U16, 9 bits, API */
    /*     Desc: Power converted to heat" */
    /*     Coded Range: [0x0...0x1FE] */
    /*     Harmonized Physical Range: [0...5100] [W] */
    /*     Original Physical Range: [0...5100] [W] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_sec_Mapping_EDU2_heatPower */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Init temporary-dst-container */
    bus_cpy = 0U;
    /* Range-Check. Potential violation of SRC.COD_LOWER_LIMIT and SRC.COD_UPPER_LIMIT */
    if((GET_Pl_PwrLossElInvt() <= 67108863.96875F) && (GET_Pl_PwrLossElInvt() >= -67108864.0F))
    {
        /* Limitation Handling. Potential violation of DST.COD_LOWER_LIMIT */
        if(GET_Pl_PwrLossElInvt() >= 0.0F)
        {
            /* Limitation Handling. Potential violation of DST.COD_UPPER_LIMIT */
            if(GET_Pl_PwrLossElInvt() <= 5100.0F)
            {
                ICS_PL_FLOAT temp_float = ((ICS_PL_FLOAT)GET_Pl_PwrLossElInvt() * (ICS_PL_FLOAT) 0.1);
                bus_cpy = (ICS_PL_U16_ICS_PL_FLOAT)(temp_float);
            }
            else
            {
                /* Automatically limit to DST.COD_UPPER_LIMIT */
                bus_cpy = 510U;
            }
        }
        else
        {
            /* Automatically limit to DST.COD_LOWER_LIMIT */
            bus_cpy = 0U;
        }
    }
    else
    {
        /* SRC is not within the valid COD-range => cancel processing */
        tmp_return_value = ICS_PL_FALSE;
    }
    if(tmp_return_value == ICS_PL_TRUE)
    {
        /* Copy temporary-dst-container to DST */
        if(WRITE_SIGNAL_DATA_API(EduSec_EDU_heatPower, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
        {
            tmp_return_value = ICS_PL_FALSE;
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduSec_EDU_heatPowerLimit
/*lint  -efile(451,ipl_hook_tx_sec_mcr.h) */
#include <ipl_hook_tx_sec_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduSec_EDU_heatPowerLimit) */
ICS_PL_RETURN_TYPE PL_Cvt_EduSec_EDU_heatPowerLimit(void)
{
    /* Conversion for TX-Bus-Signal 'EduSec_EDU_heatPowerLimit' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U16 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: Pl_PwrLossInvtMaxEstim(intc_sigcv_tx_sec) */
    /*     Category, Type, Interface: NUM, ICS_PL_FLOAT, VAR */
    /*     Desc: Maximum estimated electric power losses on IGBT and diode for inverter */
    /*     Harmonized Physical Range: [-67108864...67108863.96875] [PD_W] */
    /*     Original Physical Range: [-67108864...67108863.96875] [W] */
    /*     Variable-Name: Pl_PwrLossInvtMaxEstim */
    
    /* Destination-Signal Description: */
    /*     Name: EduSec_EDU_heatPowerLimit(intc_sigcv_tx_sec) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_U16, 9 bits, API */
    /*     Desc: Maximum power to use for heat" */
    /*     Coded Range: [0x0...0x1FE] */
    /*     Harmonized Physical Range: [0...5100] [W] */
    /*     Original Physical Range: [0...5100] [W] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_sec_Mapping_EDU2_heatPowerLimit */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Init temporary-dst-container */
    bus_cpy = 0U;
    /* Range-Check. Potential violation of SRC.COD_LOWER_LIMIT and SRC.COD_UPPER_LIMIT */
    if((GET_Pl_PwrLossInvtMaxEstim() <= 67108863.96875F) && (GET_Pl_PwrLossInvtMaxEstim() >= -67108864.0F))
    {
        /* Limitation Handling. Potential violation of DST.COD_LOWER_LIMIT */
        if(GET_Pl_PwrLossInvtMaxEstim() >= 0.0F)
        {
            /* Limitation Handling. Potential violation of DST.COD_UPPER_LIMIT */
            if(GET_Pl_PwrLossInvtMaxEstim() <= 5100.0F)
            {
                ICS_PL_FLOAT temp_float = ((ICS_PL_FLOAT)GET_Pl_PwrLossInvtMaxEstim() * (ICS_PL_FLOAT) 0.1);
                bus_cpy = (ICS_PL_U16_ICS_PL_FLOAT)(temp_float);
            }
            else
            {
                /* Automatically limit to DST.COD_UPPER_LIMIT */
                bus_cpy = 510U;
            }
        }
        else
        {
            /* Automatically limit to DST.COD_LOWER_LIMIT */
            bus_cpy = 0U;
        }
    }
    else
    {
        /* SRC is not within the valid COD-range => cancel processing */
        tmp_return_value = ICS_PL_FALSE;
    }
    if(tmp_return_value == ICS_PL_TRUE)
    {
        /* Copy temporary-dst-container to DST */
        if(WRITE_SIGNAL_DATA_API(EduSec_EDU_heatPowerLimit, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
        {
            tmp_return_value = ICS_PL_FALSE;
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduSec_EDU_igbtTemp
/*lint  -efile(451,ipl_hook_tx_sec_mcr.h) */
#include <ipl_hook_tx_sec_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduSec_EDU_igbtTemp) */
ICS_PL_RETURN_TYPE PL_Cvt_EduSec_EDU_igbtTemp(void)
{
    /* Conversion for TX-Bus-Signal 'EduSec_EDU_igbtTemp' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U8 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: Pl_PeIgbtDiodeT(intc_sigcv_tx_sec) */
    /*     Category, Type, Interface: NUM, ICS_PL_FLOAT, VAR */
    /*     Desc: Maximum semiconductor temperature of power switch for inverter */
    /*     Harmonized Physical Range: [-273.15...238.8421875] [degC] */
    /*     Original Physical Range: [0...511.9921875] [K] */
    /*     Variable-Name: Pl_PeIgbtDiodeT */
    
    /* Destination-Signal Description: */
    /*     Name: EduSec_EDU_igbtTemp(intc_sigcv_tx_sec) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_U8, 8 bits, API */
    /*     Desc: Max of all the measured igbt temperatures" */
    /*     Coded Range: [0x0...0xFE] */
    /*     Harmonized Physical Range: [-40...214] [degC] */
    /*     Original Physical Range: [-40...214] [degC] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_sec_Mapping_EDU2_igbtTemp */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Init temporary-dst-container */
    bus_cpy = 0U;
    /* Range-Check. Potential violation of SRC.COD_LOWER_LIMIT and SRC.COD_UPPER_LIMIT */
    if((GET_Pl_PeIgbtDiodeT() <= 511.9921875F) && (GET_Pl_PeIgbtDiodeT() >= 0.0F))
    {
        /* Limitation Handling. Potential violation of DST.COD_LOWER_LIMIT */
        if(GET_Pl_PeIgbtDiodeT() >= 233.15F)
        {
            /* Limitation Handling. Potential violation of DST.COD_UPPER_LIMIT */
            if(GET_Pl_PeIgbtDiodeT() <= 487.15F)
            {
                ICS_PL_FLOAT temp_float = ((ICS_PL_FLOAT)GET_Pl_PeIgbtDiodeT() + (ICS_PL_FLOAT)-233.15);
                bus_cpy = (ICS_PL_U8_ICS_PL_FLOAT)(temp_float);
            }
            else
            {
                /* Automatically limit to DST.COD_UPPER_LIMIT */
                bus_cpy = 254U;
            }
        }
        else
        {
            /* Automatically limit to DST.COD_LOWER_LIMIT */
            bus_cpy = 0U;
        }
    }
    else
    {
        /* SRC is not within the valid COD-range => cancel processing */
        tmp_return_value = ICS_PL_FALSE;
    }
    if(tmp_return_value == ICS_PL_TRUE)
    {
        /* Copy temporary-dst-container to DST */
        if(WRITE_SIGNAL_DATA_API(EduSec_EDU_igbtTemp, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
        {
            tmp_return_value = ICS_PL_FALSE;
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduSec_EDU_inverterState
/*lint  -efile(451,ipl_hook_tx_sec_mcr.h) */
#include <ipl_hook_tx_sec_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduSec_EDU_inverterState) */
ICS_PL_RETURN_TYPE PL_Cvt_EduSec_EDU_inverterState(void)
{
    /* Conversion for TX-Bus-Signal 'EduSec_EDU_inverterState' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U8 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: Pl_PeModeAct(intc_sigcv_tx_sec) */
    /*     Category, Type, Interface: TEXT, ICS_PL_U8, VAR */
    /*     Desc: Actual inverter mode reported back to vehicle */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     FCT_RDY [0x0; 0x0] */
    /*     COM_RDY [0x1; 0x1] */
    /*     TQ_CTL [0x2; 0x2] */
    /*     N_CTL [0x3; 0x3] */
    /*     SHO_ACT [0x4; 0x4] */
    /*     POSN_CAL [0x5; 0x5] */
    /*     ERR [0x6; 0x6] */
    /*     CTL_DCHA_DCV [0x7; 0x7] */
    /*     Variable-Name: Pl_PeModeAct */
    
    /* Destination-Signal Description: */
    /*     Name: EduSec_EDU_inverterState(intc_sigcv_tx_sec) */
    /*     Category, Type, length, Interface: TEXT, ICS_PL_U8, 4 bits, API */
    /*     Desc: Inverter State" */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     ACTIVE_DISCHARGE [0x7; 0x7] */
    /*     FAULT [0x6; 0x6] */
    /*     CALIBRATION [0x5; 0x5] */
    /*     ACTIVE_SHORT_CIRCUIT [0x4; 0x4] */
    /*     SPEED_CONTROL [0x3; 0x3] */
    /*     TORQUE_CONTROL [0x2; 0x2] */
    /*     COM_READY [0x1; 0x1] */
    /*     FUNCTION_READY [0x0; 0x0] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_sec_Mapping_EDU2_inverterState */
    /*     Processing: UNCONDITIONAL */
    /*     Text Mapping */
    /*     SRC -> DST */
    /*     FCT_RDY[0x0] -> FUNCTION_READY[0x0] */
    /*     COM_RDY[0x1] -> COM_READY[0x1] */
    /*     TQ_CTL[0x2] -> TORQUE_CONTROL[0x2] */
    /*     N_CTL[0x3] -> SPEED_CONTROL[0x3] */
    /*     SHO_ACT[0x4] -> ACTIVE_SHORT_CIRCUIT[0x4] */
    /*     POSN_CAL[0x5] -> CALIBRATION[0x5] */
    /*     ERR[0x6] -> FAULT[0x6] */
    /*     CTL_DCHA_DCV[0x7] -> ACTIVE_DISCHARGE[0x7] */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Init temporary-dst-container */
    bus_cpy = 0U;
    if(GET_Pl_PeModeAct() == 0U)
    {
        /* Map SRC-Value 'FCT_RDY' to DST-Value 'FUNCTION_READY' */
        bus_cpy = 0U;
    }
    else if(GET_Pl_PeModeAct() == 1U)
    {
        /* Map SRC-Value 'COM_RDY' to DST-Value 'COM_READY' */
        bus_cpy = 1U;
    }
    else if(GET_Pl_PeModeAct() == 2U)
    {
        /* Map SRC-Value 'TQ_CTL' to DST-Value 'TORQUE_CONTROL' */
        bus_cpy = 2U;
    }
    else if(GET_Pl_PeModeAct() == 3U)
    {
        /* Map SRC-Value 'N_CTL' to DST-Value 'SPEED_CONTROL' */
        bus_cpy = 3U;
    }
    else if(GET_Pl_PeModeAct() == 4U)
    {
        /* Map SRC-Value 'SHO_ACT' to DST-Value 'ACTIVE_SHORT_CIRCUIT' */
        bus_cpy = 4U;
    }
    else if(GET_Pl_PeModeAct() == 5U)
    {
        /* Map SRC-Value 'POSN_CAL' to DST-Value 'CALIBRATION' */
        bus_cpy = 5U;
    }
    else if(GET_Pl_PeModeAct() == 6U)
    {
        /* Map SRC-Value 'ERR' to DST-Value 'FAULT' */
        bus_cpy = 6U;
    }
    else if(GET_Pl_PeModeAct() == 7U)
    {
        /* Map SRC-Value 'CTL_DCHA_DCV' to DST-Value 'ACTIVE_DISCHARGE' */
        bus_cpy = 7U;
    }
    else
    {
        /* SRC is not within the valid COD-range => cancel processing */
        tmp_return_value = ICS_PL_FALSE;
    }
    if(tmp_return_value == ICS_PL_TRUE)
    {
        /* Copy temporary-dst-container to DST */
        if(WRITE_SIGNAL_DATA_API(EduSec_EDU_inverterState, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
        {
            tmp_return_value = ICS_PL_FALSE;
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduSec_EDU_nmAbleToSleep
/*lint  -efile(451,ipl_hook_tx_sec_mcr.h) */
#include <ipl_hook_tx_sec_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduSec_EDU_nmAbleToSleep) */
ICS_PL_RETURN_TYPE PL_Cvt_EduSec_EDU_nmAbleToSleep(void)
{
    /* Conversion for TX-Bus-Signal 'EduSec_EDU_nmAbleToSleep' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_FLAG bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: bNmAbleToSleep(intc_sigcv_tx_sec) */
    /*     Category, Type, Interface: TEXT, ICS_PL_FLAG, VAR */
    /*     State(s): [0x0...0x0] */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     FALSE [0x0; 0x0] */
    /*     TRUE [0x1; 0x1] */
    /*     Variable-Name: bNmAbleToSleep */
    
    /* Destination-Signal Description: */
    /*     Name: EduSec_EDU_nmAbleToSleep(intc_sigcv_tx_sec) */
    /*     Category, Type, length, Interface: TEXT, ICS_PL_FLAG, 1 bits, API */
    /*     Desc:  */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     UnableToSleep [0x0; 0x0] */
    /*     AbleToSleep [0x1; 0x1] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_sec_Mapping_EDU2_nmAbleToSleep */
    /*     Processing: UNCONDITIONAL */
    /*     Text Mapping */
    /*     SRC -> DST */
    /*     FALSE[0x0] -> UnableToSleep[0x0] */
    /*     TRUE[0x1] -> AbleToSleep[0x1] */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    if(GET_bNmAbleToSleep() == ICS_PL_FALSE)
    {
        /* Map SRC-Value 'FALSE' to DST-Value 'UnableToSleep' */
        bus_cpy = ICS_PL_FALSE;
    }
    else
    {
        /* Map SRC-Value 'TRUE' to DST-Value 'AbleToSleep' */
        bus_cpy = ICS_PL_TRUE;
    }
    /* Copy temporary-dst-container to DST */
    if(WRITE_SIGNAL_DATA_API(EduSec_EDU_nmAbleToSleep, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduSec_EDU_nmSleepError
/*lint  -efile(451,ipl_hook_tx_sec_mcr.h) */
#include <ipl_hook_tx_sec_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduSec_EDU_nmSleepError) */
ICS_PL_RETURN_TYPE PL_Cvt_EduSec_EDU_nmSleepError(void)
{
    /* Conversion for TX-Bus-Signal 'EduSec_EDU_nmSleepError' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U8 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: bNmAbleToSleep(intc_sigcv_tx_sec) */
    /*     Category, Type, Interface: TEXT, ICS_PL_FLAG, VAR */
    /*     State(s): [0x0...0x0] */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     FALSE [0x0; 0x0] */
    /*     TRUE [0x1; 0x1] */
    /*     Variable-Name: bNmAbleToSleep */
    
    /* Destination-Signal Description: */
    /*     Name: EduSec_EDU_nmSleepError(intc_sigcv_tx_sec) */
    /*     Category, Type, length, Interface: TEXT, ICS_PL_U8, 4 bits, API */
    /*     Desc:  */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     ECU_Specific_15 [0xF; 0xF] */
    /*     ECU_Specific_14 [0xE; 0xE] */
    /*     ECU_Specific_13 [0xD; 0xD] */
    /*     ECU_Specific_12 [0xC; 0xC] */
    /*     ECU_Specific_11 [0xB; 0xB] */
    /*     ECU_Specific_10 [0xA; 0xA] */
    /*     ECU_Specific_9 [0x9; 0x9] */
    /*     ECU_Specific_8 [0x8; 0x8] */
    /*     ECU_Specific_7 [0x7; 0x7] */
    /*     ECU_Specific_6 [0x6; 0x6] */
    /*     ECU_Specific_5 [0x5; 0x5] */
    /*     ECU_Specific_4 [0x4; 0x4] */
    /*     ECU_Specific_3 [0x3; 0x3] */
    /*     ECU_Specific_2 [0x2; 0x2] */
    /*     ECU_Specific_1 [0x1; 0x1] */
    /*     NONE [0x0; 0x0] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_sec_Mapping_EDU2_nmSleepError */
    /*     Processing: UNCONDITIONAL */
    /*     Text Mapping */
    /*     SRC -> DST */
    /*     FALSE[0x0] -> ECU_Specific_1[0x1] */
    /*     TRUE[0x1] -> NONE[0x0] */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    if(GET_bNmAbleToSleep() == ICS_PL_FALSE)
    {
        /* Map SRC-Value 'FALSE' to DST-Value 'ECU_Specific_1' */
        bus_cpy = 1U;
    }
    else
    {
        /* Map SRC-Value 'TRUE' to DST-Value 'NONE' */
        bus_cpy = 0U;
    }
    /* Copy temporary-dst-container to DST */
    if(WRITE_SIGNAL_DATA_API(EduSec_EDU_nmSleepError, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduSec_EDU_nmState
/*lint  -efile(451,ipl_hook_tx_sec_mcr.h) */
#include <ipl_hook_tx_sec_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduSec_EDU_nmState) */
ICS_PL_RETURN_TYPE PL_Cvt_EduSec_EDU_nmState(void)
{
    /* Conversion for TX-Bus-Signal 'EduSec_EDU_nmState' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U8 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: eCanNmState(intc_sigcv_tx_sec) */
    /*     Category, Type, Interface: TEXT, ICS_PL_U8, VAR */
    /* Desc: Datatype "U8" is expected to be OK for an enumeration variable since memory access to a single */
    /* byte should always be OK (no alignment error) even if the enumeration variable might be stored as a */
    /* wider type (e. g. 32 bit wide via the compiler option "--integer-enumeration"). */
    /*     State(s): [0x01...0x01] */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     CAN_NM_STARTUP [0x0; 0x0] */
    /*     CAN_NM_INIT [0x1; 0x1] */
    /*     CAN_NM_NORMAL_OPERATION [0x2; 0x2] */
    /*     CAN_NM_CAN_QUIET [0x3; 0x3] */
    /*     CAN_NM_SHUTDOWN [0x4; 0x4] */
    /*     CAN_NM_LOW_POWER [0x5; 0x5] */
    /*     Variable-Name: eCanNmState */
    
    /* Destination-Signal Description: */
    /*     Name: EduSec_EDU_nmState(intc_sigcv_tx_sec) */
    /*     Category, Type, length, Interface: TEXT, ICS_PL_U8, 3 bits, API */
    /*     Desc:  */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     SLEEP [0x5; 0x5] */
    /*     NORMAL_OPERATION [0x1; 0x1] */
    /*     INVALID [0x0; 0x0] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_sec_Mapping_EDU2_nmState */
    /*     Processing: UNCONDITIONAL */
    /*     Text Mapping */
    /*     SRC -> DST */
    /*     CAN_NM_STARTUP[0x0] -> INVALID[0x0] */
    /*     CAN_NM_INIT[0x1] -> INVALID[0x0] */
    /*     CAN_NM_NORMAL_OPERATION[0x2] -> NORMAL_OPERATION[0x1] */
    /*     CAN_NM_CAN_QUIET[0x3] -> SLEEP[0x5] */
    /*     CAN_NM_SHUTDOWN[0x4] -> SLEEP[0x5] */
    /*     CAN_NM_LOW_POWER[0x5] -> SLEEP[0x5] */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Init temporary-dst-container */
    bus_cpy = 0U;
    if(GET_eCanNmState() == 0U)
    {
        /* Map SRC-Value 'CAN_NM_STARTUP' to DST-Value 'INVALID' */
        bus_cpy = 0U;
    }
    else if(GET_eCanNmState() == 1U)
    {
        /* Map SRC-Value 'CAN_NM_INIT' to DST-Value 'INVALID' */
        bus_cpy = 0U;
    }
    else if(GET_eCanNmState() == 2U)
    {
        /* Map SRC-Value 'CAN_NM_NORMAL_OPERATION' to DST-Value 'NORMAL_OPERATION' */
        bus_cpy = 1U;
    }
    else if(GET_eCanNmState() == 3U)
    {
        /* Map SRC-Value 'CAN_NM_CAN_QUIET' to DST-Value 'SLEEP' */
        bus_cpy = 5U;
    }
    else if(GET_eCanNmState() == 4U)
    {
        /* Map SRC-Value 'CAN_NM_SHUTDOWN' to DST-Value 'SLEEP' */
        bus_cpy = 5U;
    }
    else if(GET_eCanNmState() == 5U)
    {
        /* Map SRC-Value 'CAN_NM_LOW_POWER' to DST-Value 'SLEEP' */
        bus_cpy = 5U;
    }
    else
    {
        /* SRC is not within the valid COD-range => cancel processing */
        tmp_return_value = ICS_PL_FALSE;
    }
    if(tmp_return_value == ICS_PL_TRUE)
    {
        /* Copy temporary-dst-container to DST */
        if(WRITE_SIGNAL_DATA_API(EduSec_EDU_nmState, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
        {
            tmp_return_value = ICS_PL_FALSE;
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduSec_EDU_outputShaftTorque
/*lint  -efile(451,ipl_hook_tx_sec_mcr.h) */
#include <ipl_hook_tx_sec_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduSec_EDU_outputShaftTorque) */
ICS_PL_RETURN_TYPE PL_Cvt_EduSec_EDU_outputShaftTorque(void)
{
    /* Conversion for TX-Bus-Signal 'EduSec_EDU_outputShaftTorque' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_S16 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: Pl_WhlTqEstimdAct(intc_sigcv_tx_sec) */
    /*     Category, Type, Interface: NUM, ICS_PL_FLOAT, VAR */
    /*     Desc: Actual available torque at wheels considering limitation of electrical machine. */
    /*     Harmonized Physical Range: [-4096...4095.875] [PD_Nm] */
    /*     Original Physical Range: [-4096...4095.875] [Nm] */
    /*     Variable-Name: Pl_WhlTqEstimdAct */
    
    /* Destination-Signal Description: */
    /*     Name: EduSec_EDU_outputShaftTorque(intc_sigcv_tx_sec) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_S16, 13 bits, API */
    /*     Desc: Torque at the Output Shaft" */
    /*     Coded Range: [0xF4AC...0xB54] */
    /*     Harmonized Physical Range: [-2900...2900] [Nm] */
    /*     Original Physical Range: [-2900...2900] [Nm] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_sec_Mapping_EDU2_outputShaftTorque */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Init temporary-dst-container */
    bus_cpy = 0;
    /* Range-Check. Potential violation of SRC.COD_LOWER_LIMIT and SRC.COD_UPPER_LIMIT */
    if((GET_Pl_WhlTqEstimdAct() <= 4095.875F) && (GET_Pl_WhlTqEstimdAct() >= -4096.0F))
    {
        /* Limitation Handling. Potential violation of DST.COD_LOWER_LIMIT */
        if(GET_Pl_WhlTqEstimdAct() >= -2900.0F)
        {
            /* Limitation Handling. Potential violation of DST.COD_UPPER_LIMIT */
            if(GET_Pl_WhlTqEstimdAct() <= 2900.0F)
            {
                ICS_PL_FLOAT temp_float = ((ICS_PL_FLOAT)GET_Pl_WhlTqEstimdAct());
                bus_cpy = (ICS_PL_S16_ICS_PL_FLOAT)(temp_float);
            }
            else
            {
                /* Automatically limit to DST.COD_UPPER_LIMIT */
                bus_cpy = 2900;
            }
        }
        else
        {
            /* Automatically limit to DST.COD_LOWER_LIMIT */
            bus_cpy = ((ICS_PL_S16)-2900);
        }
    }
    else
    {
        /* SRC is not within the valid COD-range => cancel processing */
        tmp_return_value = ICS_PL_FALSE;
    }
    if(tmp_return_value == ICS_PL_TRUE)
    {
        /* Copy temporary-dst-container to DST */
        if(WRITE_SIGNAL_DATA_API(EduSec_EDU_outputShaftTorque, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
        {
            tmp_return_value = ICS_PL_FALSE;
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduSec_EDU_outputShaftTorqueLimMax
/*lint  -efile(451,ipl_hook_tx_sec_mcr.h) */
#include <ipl_hook_tx_sec_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduSec_EDU_outputShaftTorqueLimMax) */
ICS_PL_RETURN_TYPE PL_Cvt_EduSec_EDU_outputShaftTorqueLimMax(void)
{
    /* Conversion for TX-Bus-Signal 'EduSec_EDU_outputShaftTorqueLimMax' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U16 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: Pl_WhlTqMaxEstimdLimAct(intc_sigcv_tx_sec) */
    /*     Category, Type, Interface: NUM, ICS_PL_FLOAT, VAR */
    /*     Desc: Maximum available torque at wheels considering limitation of electrical machine. */
    /*     Harmonized Physical Range: [-4096...4095.875] [PD_Nm] */
    /*     Original Physical Range: [-4096...4095.875] [Nm] */
    /*     Variable-Name: Pl_WhlTqMaxEstimdLimAct */
    
    /* Destination-Signal Description: */
    /*     Name: EduSec_EDU_outputShaftTorqueLimMax(intc_sigcv_tx_sec) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_U16, 13 bits, API */
    /*     Desc: Torque Limit in the EDU's forward direction" */
    /*     Coded Range: [0x0...0xB54] */
    /*     Harmonized Physical Range: [0...2900] [Nm] */
    /*     Original Physical Range: [0...2900] [Nm] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_sec_Mapping_EDU2_outputShaftTorqueLimMax */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Init temporary-dst-container */
    bus_cpy = 0U;
    /* Range-Check. Potential violation of SRC.COD_LOWER_LIMIT and SRC.COD_UPPER_LIMIT */
    if((GET_Pl_WhlTqMaxEstimdLimAct() <= 4095.875F) && (GET_Pl_WhlTqMaxEstimdLimAct() >= -4096.0F))
    {
        /* Limitation Handling. Potential violation of DST.COD_LOWER_LIMIT */
        if(GET_Pl_WhlTqMaxEstimdLimAct() >= 0.0F)
        {
            /* Limitation Handling. Potential violation of DST.COD_UPPER_LIMIT */
            if(GET_Pl_WhlTqMaxEstimdLimAct() <= 2900.0F)
            {
                ICS_PL_FLOAT temp_float = ((ICS_PL_FLOAT)GET_Pl_WhlTqMaxEstimdLimAct());
                bus_cpy = (ICS_PL_U16_ICS_PL_FLOAT)(temp_float);
            }
            else
            {
                /* Automatically limit to DST.COD_UPPER_LIMIT */
                bus_cpy = 2900U;
            }
        }
        else
        {
            /* Automatically limit to DST.COD_LOWER_LIMIT */
            bus_cpy = 0U;
        }
    }
    else
    {
        /* SRC is not within the valid COD-range => cancel processing */
        tmp_return_value = ICS_PL_FALSE;
    }
    if(tmp_return_value == ICS_PL_TRUE)
    {
        /* Copy temporary-dst-container to DST */
        if(WRITE_SIGNAL_DATA_API(EduSec_EDU_outputShaftTorqueLimMax, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
        {
            tmp_return_value = ICS_PL_FALSE;
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduSec_EDU_outputShaftTorqueLimMin
/*lint  -efile(451,ipl_hook_tx_sec_mcr.h) */
#include <ipl_hook_tx_sec_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduSec_EDU_outputShaftTorqueLimMin) */
ICS_PL_RETURN_TYPE PL_Cvt_EduSec_EDU_outputShaftTorqueLimMin(void)
{
    /* Conversion for TX-Bus-Signal 'EduSec_EDU_outputShaftTorqueLimMin' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U16 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: Pl_WhlTqMinEstimdLimAct(intc_sigcv_tx_sec) */
    /*     Category, Type, Interface: NUM, ICS_PL_FLOAT, VAR */
    /*     Desc: Minimum available torque at wheels considering limitation of electrical machine. */
    /*     Harmonized Physical Range: [-4096...4095.875] [PD_Nm] */
    /*     Original Physical Range: [-4096...4095.875] [Nm] */
    /*     Variable-Name: Pl_WhlTqMinEstimdLimAct */
    
    /* Destination-Signal Description: */
    /*     Name: EduSec_EDU_outputShaftTorqueLimMin(intc_sigcv_tx_sec) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_U16, 13 bits, API */
    /*     Desc: Torque Limit in the EDU's reverse direction" */
    /*     Coded Range: [0x0...0xB54] */
    /*     Harmonized Physical Range: [0...2900] [Nm] */
    /*     Original Physical Range: [0...2900] [Nm] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_sec_Mapping_EDU2_outputShaftTorqueLimMin */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Init temporary-dst-container */
    bus_cpy = 0U;
    /* Range-Check. Potential violation of SRC.COD_LOWER_LIMIT and SRC.COD_UPPER_LIMIT */
    if((GET_Pl_WhlTqMinEstimdLimAct() <= 4095.875F) && (GET_Pl_WhlTqMinEstimdLimAct() >= -4096.0F))
    {
        /* Limitation Handling. Potential violation of DST.COD_LOWER_LIMIT */
        if(GET_Pl_WhlTqMinEstimdLimAct() >= 0.0F)
        {
            /* Limitation Handling. Potential violation of DST.COD_UPPER_LIMIT */
            if(GET_Pl_WhlTqMinEstimdLimAct() <= 2900.0F)
            {
                ICS_PL_FLOAT temp_float = ((ICS_PL_FLOAT)GET_Pl_WhlTqMinEstimdLimAct());
                bus_cpy = (ICS_PL_U16_ICS_PL_FLOAT)(temp_float);
            }
            else
            {
                /* Automatically limit to DST.COD_UPPER_LIMIT */
                bus_cpy = 2900U;
            }
        }
        else
        {
            /* Automatically limit to DST.COD_LOWER_LIMIT */
            bus_cpy = 0U;
        }
    }
    else
    {
        /* SRC is not within the valid COD-range => cancel processing */
        tmp_return_value = ICS_PL_FALSE;
    }
    if(tmp_return_value == ICS_PL_TRUE)
    {
        /* Copy temporary-dst-container to DST */
        if(WRITE_SIGNAL_DATA_API(EduSec_EDU_outputShaftTorqueLimMin, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
        {
            tmp_return_value = ICS_PL_FALSE;
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduSec_EDU_outputShaftTorqueValid
/*lint  -efile(451,ipl_hook_tx_sec_mcr.h) */
#include <ipl_hook_tx_sec_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduSec_EDU_outputShaftTorqueValid) */
ICS_PL_RETURN_TYPE PL_Cvt_EduSec_EDU_outputShaftTorqueValid(void)
{
    /* Conversion for TX-Bus-Signal 'EduSec_EDU_outputShaftTorqueValid' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_FLAG bus_cpy;
    
    
    /* Destination-Signal Description: */
    /*     Name: EduSec_EDU_outputShaftTorqueValid(intc_sigcv_tx_sec) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_FLAG, 1 bits, API */
    /*     Desc: Output Shaft torque valid" */
    /*     Coded Range: [0x0...0x1] */
    /*     Harmonized Physical Range: [0...1] [NoUnit] */
    /*     Original Physical Range: [0...1] [NoUnit] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_sec_Mapping_EDU2_outputShaftTorqueValid */
    /*     Processing: STUB */
    /*     Stub-Value: Dst-Signal.USER_VALUE */
    /*     Processing-Value-User-Value: 0x1 */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Stub DST to USER_VALUE */
    bus_cpy = ICS_PL_TRUE;
    /* Copy temporary-dst-container to DST */
    if(WRITE_SIGNAL_DATA_API(EduSec_EDU_outputShaftTorqueValid, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduSec_EDU_rotorPosition
/*lint  -efile(451,ipl_hook_tx_sec_mcr.h) */
#include <ipl_hook_tx_sec_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduSec_EDU_rotorPosition) */
ICS_PL_RETURN_TYPE PL_Cvt_EduSec_EDU_rotorPosition(void)
{
    /* Conversion for TX-Bus-Signal 'EduSec_EDU_rotorPosition' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U16 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: f32AngRotorEstim(intc_sigcv_tx_sec) */
    /*     Category, Type, Interface: NUM, ICS_PL_FLOAT, VAR */
    /*     Desc: Observer estimated rotor angle */
    /*     Harmonized Physical Range: [0...360] [deg] */
    /*     Original Physical Range: [0...6.283185482025] [rad] */
    /*     Variable-Name: f32AngRotorEstim */
    
    /* Destination-Signal Description: */
    /*     Name: EduSec_EDU_rotorPosition(intc_sigcv_tx_sec) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_U16, 12 bits, API */
    /*     Desc: Rotation Angle of the Rotor" */
    /*     Coded Range: [0x0...0xFFB] */
    /*     Harmonized Physical Range: [0...360] [deg] */
    /*     Original Physical Range: [0...360] [deg] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_sec_Mapping_EDU2_rotorPosition */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Init temporary-dst-container */
    bus_cpy = 0U;
    /* Range-Check. Potential violation of SRC.COD_LOWER_LIMIT and SRC.COD_UPPER_LIMIT */
    if((GET_f32AngRotorEstim() <= 6.283185482025F) && (GET_f32AngRotorEstim() >= 0.0F))
    {
        ICS_PL_FLOAT temp_float = ((ICS_PL_FLOAT)GET_f32AngRotorEstim() * (ICS_PL_FLOAT) 651.1028540703714384868832229769);
        bus_cpy = (ICS_PL_U16_ICS_PL_FLOAT)(temp_float);
    }
    else
    {
        /* SRC is not within the valid COD-range => cancel processing */
        tmp_return_value = ICS_PL_FALSE;
    }
    if(tmp_return_value == ICS_PL_TRUE)
    {
        /* Copy temporary-dst-container to DST */
        if(WRITE_SIGNAL_DATA_API(EduSec_EDU_rotorPosition, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
        {
            tmp_return_value = ICS_PL_FALSE;
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduSec_EDU_rotorPositionValid
/*lint  -efile(451,ipl_hook_tx_sec_mcr.h) */
#include <ipl_hook_tx_sec_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduSec_EDU_rotorPositionValid) */
ICS_PL_RETURN_TYPE PL_Cvt_EduSec_EDU_rotorPositionValid(void)
{
    /* Conversion for TX-Bus-Signal 'EduSec_EDU_rotorPositionValid' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_FLAG bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: Pl_LvStPosnRotorVld(intc_sigcv_tx_sec) */
    /*     Category, Type, Interface: TEXT, ICS_PL_FLAG, VAR */
    /*     Desc: Valid flag for rotor position based on rotor position sensor diagnosis */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     FALSE [0x0; 0x0] */
    /*     TRUE [0x1; 0x1] */
    /*     Variable-Name: Pl_LvStPosnRotorVld */
    
    /* Destination-Signal Description: */
    /*     Name: EduSec_EDU_rotorPositionValid(intc_sigcv_tx_sec) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_FLAG, 1 bits, API */
    /*     Desc: Rotation Angle of the Rotor valid" */
    /*     Coded Range: [0x0...0x1] */
    /*     Harmonized Physical Range: [0...1] [NoUnit] */
    /*     Original Physical Range: [0...1] [NoUnit] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_sec_Mapping_EDU2_rotorPositionValid */
    /*     Processing: FORCE */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Force PL to perform an 1:1 mapping  */
    if(GET_Pl_LvStPosnRotorVld() == ICS_PL_TRUE)
    {
        bus_cpy = ICS_PL_TRUE;
    }
    else
    {
        bus_cpy = ICS_PL_FALSE;
    }
    /* Copy temporary-dst-container to DST */
    if(WRITE_SIGNAL_DATA_API(EduSec_EDU_rotorPositionValid, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduSec_EDU_rotorSpeed
/*lint  -efile(451,ipl_hook_tx_sec_mcr.h) */
#include <ipl_hook_tx_sec_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduSec_EDU_rotorSpeed) */
ICS_PL_RETURN_TYPE PL_Cvt_EduSec_EDU_rotorSpeed(void)
{
    /* Conversion for TX-Bus-Signal 'EduSec_EDU_rotorSpeed' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_S16 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: f32NRotorLpfSlow(intc_sigcv_tx_sec) */
    /*     Category, Type, Interface: NUM, ICS_PL_FLOAT, VAR */
    /*     Desc: Actual rpm from electric machine */
    /*     Harmonized Physical Range: [-32768...32767] [rpm] */
    /*     Original Physical Range: [-32768...32767] [rpm] */
    /*     Variable-Name: f32NRotorLpfSlow */
    
    /* Destination-Signal Description: */
    /*     Name: EduSec_EDU_rotorSpeed(intc_sigcv_tx_sec) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_S16, 14 bits, API */
    /*     Desc: Rotor speed, not scaled by gearbox ratio" */
    /*     Coded Range: [0xE03E...0x1FC2] */
    /*     Harmonized Physical Range: [-10000...10000] [rpm] */
    /*     Original Physical Range: [-10000...10000] [rpm] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_sec_Mapping_EDU2_rotorSpeed */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Init temporary-dst-container */
    bus_cpy = 0;
    /* Range-Check. Potential violation of SRC.COD_LOWER_LIMIT and SRC.COD_UPPER_LIMIT */
    if((GET_f32NRotorLpfSlow() <= 32767.0F) && (GET_f32NRotorLpfSlow() >= -32768.0F))
    {
        /* Limitation Handling. Potential violation of DST.COD_LOWER_LIMIT */
        if(GET_f32NRotorLpfSlow() >= -10000.0F)
        {
            /* Limitation Handling. Potential violation of DST.COD_UPPER_LIMIT */
            if(GET_f32NRotorLpfSlow() <= 10000.0F)
            {
                ICS_PL_FLOAT temp_float = ((ICS_PL_FLOAT)GET_f32NRotorLpfSlow() * (ICS_PL_FLOAT) 0.813);
                bus_cpy = (ICS_PL_S16_ICS_PL_FLOAT)(temp_float);
            }
            else
            {
                /* Automatically limit to DST.COD_UPPER_LIMIT */
                bus_cpy = 8130;
            }
        }
        else
        {
            /* Automatically limit to DST.COD_LOWER_LIMIT */
            bus_cpy = ((ICS_PL_S16)-8130);
        }
    }
    else
    {
        /* SRC is not within the valid COD-range => cancel processing */
        tmp_return_value = ICS_PL_FALSE;
    }
    if(tmp_return_value == ICS_PL_TRUE)
    {
        /* Copy temporary-dst-container to DST */
        if(WRITE_SIGNAL_DATA_API(EduSec_EDU_rotorSpeed, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
        {
            tmp_return_value = ICS_PL_FALSE;
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduSec_EDU_rotorSpeedValid
/*lint  -efile(451,ipl_hook_tx_sec_mcr.h) */
#include <ipl_hook_tx_sec_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduSec_EDU_rotorSpeedValid) */
ICS_PL_RETURN_TYPE PL_Cvt_EduSec_EDU_rotorSpeedValid(void)
{
    /* Conversion for TX-Bus-Signal 'EduSec_EDU_rotorSpeedValid' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_FLAG bus_cpy;
    
    
    /* Destination-Signal Description: */
    /*     Name: EduSec_EDU_rotorSpeedValid(intc_sigcv_tx_sec) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_FLAG, 1 bits, API */
    /*     Desc: Rotor speed valid" */
    /*     Coded Range: [0x0...0x1] */
    /*     Harmonized Physical Range: [0...1] [NoUnit] */
    /*     Original Physical Range: [0...1] [NoUnit] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_sec_Mapping_EDU2_rotorSpeedValid */
    /*     Processing: STUB */
    /*     Stub-Value: Dst-Signal.USER_VALUE */
    /*     Processing-Value-User-Value: 0x1 */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Stub DST to USER_VALUE */
    bus_cpy = ICS_PL_TRUE;
    /* Copy temporary-dst-container to DST */
    if(WRITE_SIGNAL_DATA_API(EduSec_EDU_rotorSpeedValid, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduSec_EDU_rotorTemp
/*lint  -efile(451,ipl_hook_tx_sec_mcr.h) */
#include <ipl_hook_tx_sec_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduSec_EDU_rotorTemp) */
ICS_PL_RETURN_TYPE PL_Cvt_EduSec_EDU_rotorTemp(void)
{
    /* Conversion for TX-Bus-Signal 'EduSec_EDU_rotorTemp' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U8 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: Pl_EmRotorTEstimd(intc_sigcv_tx_sec) */
    /*     Category, Type, Interface: NUM, ICS_PL_FLOAT, VAR */
    /* Desc: Permanent Magnet Synchronous Machine rotor temperature value for protection of electric */
    /* machine */
    /*     Harmonized Physical Range: [-273.15...238.8421875] [degC] */
    /*     Original Physical Range: [0...511.9921875] [K] */
    /*     Variable-Name: Pl_EmRotorTEstimd */
    
    /* Destination-Signal Description: */
    /*     Name: EduSec_EDU_rotorTemp(intc_sigcv_tx_sec) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_U8, 8 bits, API */
    /*     Desc: Estimated rotor temperature" */
    /*     Coded Range: [0x0...0xFE] */
    /*     Harmonized Physical Range: [-40...214] [degC] */
    /*     Original Physical Range: [-40...214] [degC] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_sec_Mapping_EDU2_rotorTemp */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Init temporary-dst-container */
    bus_cpy = 0U;
    /* Range-Check. Potential violation of SRC.COD_LOWER_LIMIT and SRC.COD_UPPER_LIMIT */
    if((GET_Pl_EmRotorTEstimd() <= 511.9921875F) && (GET_Pl_EmRotorTEstimd() >= 0.0F))
    {
        /* Limitation Handling. Potential violation of DST.COD_LOWER_LIMIT */
        if(GET_Pl_EmRotorTEstimd() >= 233.15F)
        {
            /* Limitation Handling. Potential violation of DST.COD_UPPER_LIMIT */
            if(GET_Pl_EmRotorTEstimd() <= 487.15F)
            {
                ICS_PL_FLOAT temp_float = ((ICS_PL_FLOAT)GET_Pl_EmRotorTEstimd() + (ICS_PL_FLOAT)-233.15);
                bus_cpy = (ICS_PL_U8_ICS_PL_FLOAT)(temp_float);
            }
            else
            {
                /* Automatically limit to DST.COD_UPPER_LIMIT */
                bus_cpy = 254U;
            }
        }
        else
        {
            /* Automatically limit to DST.COD_LOWER_LIMIT */
            bus_cpy = 0U;
        }
    }
    else
    {
        /* SRC is not within the valid COD-range => cancel processing */
        tmp_return_value = ICS_PL_FALSE;
    }
    if(tmp_return_value == ICS_PL_TRUE)
    {
        /* Copy temporary-dst-container to DST */
        if(WRITE_SIGNAL_DATA_API(EduSec_EDU_rotorTemp, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
        {
            tmp_return_value = ICS_PL_FALSE;
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduSec_EDU_statorTemp
/*lint  -efile(451,ipl_hook_tx_sec_mcr.h) */
#include <ipl_hook_tx_sec_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduSec_EDU_statorTemp) */
ICS_PL_RETURN_TYPE PL_Cvt_EduSec_EDU_statorTemp(void)
{
    /* Conversion for TX-Bus-Signal 'EduSec_EDU_statorTemp' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U8 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: Pl_EmStatorTHotSpotEstimd(intc_sigcv_tx_sec) */
    /*     Category, Type, Interface: NUM, ICS_PL_FLOAT, VAR */
    /*     Desc: Filtered estimated stator temperature */
    /*     Harmonized Physical Range: [-273.15...238.8421875] [degC] */
    /*     Original Physical Range: [0...511.9921875] [K] */
    /*     Variable-Name: Pl_EmStatorTHotSpotEstimd */
    
    /* Destination-Signal Description: */
    /*     Name: EduSec_EDU_statorTemp(intc_sigcv_tx_sec) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_U8, 8 bits, API */
    /*     Desc: Max of all the measured stator temperatures" */
    /*     Coded Range: [0x0...0xFE] */
    /*     Harmonized Physical Range: [-40...214] [degC] */
    /*     Original Physical Range: [-40...214] [degC] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_sec_Mapping_EDU2_statorTemp */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Init temporary-dst-container */
    bus_cpy = 0U;
    /* Range-Check. Potential violation of SRC.COD_LOWER_LIMIT and SRC.COD_UPPER_LIMIT */
    if((GET_Pl_EmStatorTHotSpotEstimd() <= 511.9921875F) && (GET_Pl_EmStatorTHotSpotEstimd() >= 0.0F))
    {
        /* Limitation Handling. Potential violation of DST.COD_LOWER_LIMIT */
        if(GET_Pl_EmStatorTHotSpotEstimd() >= 233.15F)
        {
            /* Limitation Handling. Potential violation of DST.COD_UPPER_LIMIT */
            if(GET_Pl_EmStatorTHotSpotEstimd() <= 487.15F)
            {
                ICS_PL_FLOAT temp_float = ((ICS_PL_FLOAT)GET_Pl_EmStatorTHotSpotEstimd() + (ICS_PL_FLOAT)-233.15);
                bus_cpy = (ICS_PL_U8_ICS_PL_FLOAT)(temp_float);
            }
            else
            {
                /* Automatically limit to DST.COD_UPPER_LIMIT */
                bus_cpy = 254U;
            }
        }
        else
        {
            /* Automatically limit to DST.COD_LOWER_LIMIT */
            bus_cpy = 0U;
        }
    }
    else
    {
        /* SRC is not within the valid COD-range => cancel processing */
        tmp_return_value = ICS_PL_FALSE;
    }
    if(tmp_return_value == ICS_PL_TRUE)
    {
        /* Copy temporary-dst-container to DST */
        if(WRITE_SIGNAL_DATA_API(EduSec_EDU_statorTemp, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
        {
            tmp_return_value = ICS_PL_FALSE;
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduSec_EDU_voltageDc
/*lint  -efile(451,ipl_hook_tx_sec_mcr.h) */
#include <ipl_hook_tx_sec_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduSec_EDU_voltageDc) */
ICS_PL_RETURN_TYPE PL_Cvt_EduSec_EDU_voltageDc(void)
{
    /* Conversion for TX-Bus-Signal 'EduSec_EDU_voltageDc' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U16 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: Pl_HvDcUMeasd(intc_sigcv_tx_sec) */
    /*     Category, Type, Interface: NUM, ICS_PL_S16, VAR */
    /*     Desc: Second low pass filtered of primary voltage sensor */
    /*     Coded Range: [0x8000...0x7FFF] */
    /*     Harmonized Physical Range: [-2048...2047.9375] [PD_V] */
    /*     Original Physical Range: [-2048...2047.9375] [V] */
    /*     Variable-Name: Pl_HvDcUMeasd */
    
    /* Destination-Signal Description: */
    /*     Name: EduSec_EDU_voltageDc(intc_sigcv_tx_sec) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_U16, 9 bits, API */
    /*     Desc: High voltage bus measurement" */
    /*     Coded Range: [0x0...0x1FF] */
    /*     Harmonized Physical Range: [0...511] [V] */
    /*     Original Physical Range: [0...511] [V] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_sec_Mapping_EDU2_voltageDc */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Init temporary-dst-container */
    bus_cpy = 0U;
    /* Limitation Handling. Potential violation of DST.COD_LOWER_LIMIT */
    if(GET_Pl_HvDcUMeasd() >= 0)
    {
        /* Limitation Handling. Potential violation of DST.COD_UPPER_LIMIT */
        if(GET_Pl_HvDcUMeasd() <= 8168)
        {
            /* Conversion of 'Pl_HvDcUMeasd' to 'EduSec_EDU_voltageDc' */
            /*lint -save -e734 */
            /*lint -save -e571 */
            bus_cpy = ((((ICS_PL_U16)GET_Pl_HvDcUMeasd()) + 8U) / 16U);
            /*lint -restore */
            /*lint -restore */
        }
        else
        {
            /* Automatically limit to DST.COD_UPPER_LIMIT */
            bus_cpy = 511U;
        }
    }
    else
    {
        /* Automatically limit to DST.COD_LOWER_LIMIT */
        bus_cpy = 0U;
    }
    /* Copy temporary-dst-container to DST */
    if(WRITE_SIGNAL_DATA_API(EduSec_EDU_voltageDc, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
