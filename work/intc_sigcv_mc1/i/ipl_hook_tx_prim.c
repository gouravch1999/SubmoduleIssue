/****************************************************************************
 * COPYRIGHT VITESCO TECHNOLOGIES GROUP AG (EXCLUSIVE RIGHTS) 
 * Confidential
 * 
 * The reproduction, transmission or use of this document or its
 * contents is not permitted without express written authority.
 * Offenders will be liable for damages. All rights, including rights
 * created by patent grant or registration of a utility model or design,
 * are reserved.
 *---------------------------------------------------------------------------
 * 
 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 * !!! This file is generated by Signal Mapper (SIMA) Code-Generator !!!
 * !!! Do NOT modify this file manually                            !!!
 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 * 
 * Purpose:    PL Hook Implementation
 * 
 * Processor:  independent
 * Tool chain: 
 *    CG-Version:        6.2.0
 *    Schema-Version:    1.18.0
 *    Generation-Date:   26.08.2024  18:11:04  
 *    Generated by user: uiv00534
 * Filename:   $Workfile$
 * Revision:   $Revision: 1.1 $
 * Author:     $Author: Zhang Yi (uiv00534) (uiv00534) $
 * Date:       $Date: 2024/09/03 03:20:49CEST $
 * Changes:    $Log: ipl_hook_tx_prim.c  $
 * Changes:    Revision 1.1 2024/09/03 03:20:49CEST Zhang Yi (uiv00534) (uiv00534) 
 * Changes:    Initial revision
 * Changes:    Member added to project /ES/FS/0G/H0D/0A/bsw/intc/intc_sigcv_mc1/i/project.pj
 * 
****************************************************************************/
/*lint -esym(750,IPL_HOOK_TX_PRIM_C) */
#define IPL_HOOK_TX_PRIM_C
#include <intc_sigcv_mc1_im.h>


#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EDU1_activeDischFeatEn
/*lint  -efile(451,ipl_hook_tx_prim_mcr.h) */
#include <ipl_hook_tx_prim_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EDU1_activeDischFeatEn) */
ICS_PL_RETURN_TYPE PL_Cvt_EDU1_activeDischFeatEn(void)
{
    /* Conversion for TX-Bus-Signal 'EDU1_activeDischFeatEn' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_FLAG bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: Pl_AcvDchaSts(intc_sigcv_tx_prim) */
    /*     Category, Type, Interface: TEXT, ICS_PL_FLAG, VAR */
    /*     Desc: Active discharge enabled */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     FALSE [0x0; 0x0] */
    /*     TRUE [0x1; 0x1] */
    /*     Variable-Name: Pl_AcvDchaSts */
    
    /* Destination-Signal Description: */
    /*     Name: EDU1_activeDischFeatEn(intc_sigcv_tx_prim) */
    /*     Category, Type, length, Interface: TEXT, ICS_PL_FLAG, 1 bits, API */
    /*     Desc: Inverter Active Discharge Feature Enabled" */
    /*     State(s): [0x0...    ] */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     FALSE [0x0; 0x0] */
    /*     TRUE [0x1; 0x1] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_prim_Mapping_EDU1_activeDischFeatEn */
    /*     Processing: UNCONDITIONAL */
    /*     Text Mapping */
    /*     SRC -> DST */
    /*     FALSE[0x0] -> FALSE[0x0] */
    /*     TRUE[0x1] -> TRUE[0x1] */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    if(GET_Pl_AcvDchaSts() == ICS_PL_FALSE)
    {
        /* Map SRC-Value 'FALSE' to DST-Value 'FALSE' */
        bus_cpy = ICS_PL_FALSE;
    }
    else
    {
        /* Map SRC-Value 'TRUE' to DST-Value 'TRUE' */
        bus_cpy = ICS_PL_TRUE;
    }
    /* Copy temporary-dst-container to DST */
    if(WRITE_SIGNAL_DATA_API(EDU1_activeDischFeatEn, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EDU1_clutchState
/*lint  -efile(451,ipl_hook_tx_prim_mcr.h) */
#include <ipl_hook_tx_prim_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EDU1_clutchState) */
ICS_PL_RETURN_TYPE PL_Cvt_EDU1_clutchState(void)
{
    /* Conversion for TX-Bus-Signal 'EDU1_clutchState' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U8 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: Pl_CluAxleSt(intc_sigcv_tx_prim) */
    /*     Category, Type, Interface: TEXT, ICS_PL_U8, VAR */
    /*     Desc: Operational state of electrical machine clutch */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     INI [0x0; 0x0] */
    /*     DISCNCT [0x1; 0x1] */
    /*     TRAN [0x2; 0x2] */
    /*     CNCT [0x3; 0x3] */
    /*     ERR [0x4; 0x4] */
    /*     Variable-Name: Pl_CluAxleSt */
    
    /* Destination-Signal Description: */
    /*     Name: EDU1_clutchState(intc_sigcv_tx_prim) */
    /*     Category, Type, length, Interface: TEXT, ICS_PL_U8, 3 bits, API */
    /*     Desc: Clutch1 Control Status" */
    /*     State(s): [0x0...    ] */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     IN_TRANSITION [0x6; 0x6] */
    /*     FAULT [0x5; 0x5] */
    /*     ENGAGING [0x4; 0x4] */
    /*     ENGAGED [0x3; 0x3] */
    /*     DISENGAGING [0x2; 0x2] */
    /*     DISENGAGED [0x1; 0x1] */
    /*     UNKNOWN [0x0; 0x0] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_prim_Mapping_EDU1_clutchState */
    /*     Processing: BYPASS */
    /*     Bypass-Callout: ByPass_EDU_clutchState */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Init temporary-dst-container */
    bus_cpy = 0U;
    
    /* Bypass PL */
    if(ByPass_EDU_clutchState(GET_Pl_CluAxleSt(), &bus_cpy) == ICS_PL_TRUE)
    {
        /* Copy temporary-dst-container to DST */
        if(WRITE_SIGNAL_DATA_API(EDU1_clutchState, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
        {
            tmp_return_value = ICS_PL_FALSE;
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EDU1_comStatusPrimary
/*lint  -efile(451,ipl_hook_tx_prim_mcr.h) */
#include <ipl_hook_tx_prim_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EDU1_comStatusPrimary) */
ICS_PL_RETURN_TYPE PL_Cvt_EDU1_comStatusPrimary(void)
{
    /* Conversion for TX-Bus-Signal 'EDU1_comStatusPrimary' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U8 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: u8ComStatusPrimary(intc_sigcv_tx_prim) */
    /*     Category, Type, Interface: TEXT, ICS_PL_U8, VAR */
    /*     State(s): [0x0...0x0] */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     UNAVAILABLE [0x0; 0x0] */
    /*     BACKUP [0x1; 0x1] */
    /*     ACTIVE [0x2; 0x2] */
    /*     Variable-Name: u8ComStatusPrimary */
    
    /* Destination-Signal Description: */
    /*     Name: EDU1_comStatusPrimary(intc_sigcv_tx_prim) */
    /*     Category, Type, length, Interface: TEXT, ICS_PL_U8, 2 bits, API */
    /*     Desc:  */
    /*     State(s): [0x0...    ] */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     ACTIVE [0x2; 0x2] */
    /*     BACKUP [0x1; 0x1] */
    /*     UNAVAILABLE [0x0; 0x0] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_prim_Mapping_EDU1_comStatusPrimary */
    /*     Processing: UNCONDITIONAL */
    /*     Text Mapping */
    /*     SRC -> DST */
    /*     UNAVAILABLE[0x0] -> UNAVAILABLE[0x0] */
    /*     BACKUP[0x1] -> BACKUP[0x1] */
    /*     ACTIVE[0x2] -> ACTIVE[0x2] */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Init temporary-dst-container */
    bus_cpy = 0U;
    if(GET_u8ComStatusPrimary() == 0U)
    {
        /* Map SRC-Value 'UNAVAILABLE' to DST-Value 'UNAVAILABLE' */
        bus_cpy = 0U;
    }
    else if(GET_u8ComStatusPrimary() == 1U)
    {
        /* Map SRC-Value 'BACKUP' to DST-Value 'BACKUP' */
        bus_cpy = 1U;
    }
    else if(GET_u8ComStatusPrimary() == 2U)
    {
        /* Map SRC-Value 'ACTIVE' to DST-Value 'ACTIVE' */
        bus_cpy = 2U;
    }
    else
    {
        /* SRC is not within the valid COD-range => cancel processing */
        tmp_return_value = ICS_PL_FALSE;
    }
    if(tmp_return_value == ICS_PL_TRUE)
    {
        /* Copy temporary-dst-container to DST */
        if(WRITE_SIGNAL_DATA_API(EDU1_comStatusPrimary, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
        {
            tmp_return_value = ICS_PL_FALSE;
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EDU1_comStatusSecondary
/*lint  -efile(451,ipl_hook_tx_prim_mcr.h) */
#include <ipl_hook_tx_prim_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EDU1_comStatusSecondary) */
ICS_PL_RETURN_TYPE PL_Cvt_EDU1_comStatusSecondary(void)
{
    /* Conversion for TX-Bus-Signal 'EDU1_comStatusSecondary' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U8 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: u8ComStatusSecondary(intc_sigcv_tx_prim) */
    /*     Category, Type, Interface: TEXT, ICS_PL_U8, VAR */
    /*     State(s): [0x0...0x0] */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     UNAVAILABLE [0x0; 0x0] */
    /*     BACKUP [0x1; 0x1] */
    /*     ACTIVE [0x2; 0x2] */
    /*     Variable-Name: u8ComStatusSecondary */
    
    /* Destination-Signal Description: */
    /*     Name: EDU1_comStatusSecondary(intc_sigcv_tx_prim) */
    /*     Category, Type, length, Interface: TEXT, ICS_PL_U8, 2 bits, API */
    /*     Desc:  */
    /*     State(s): [0x0...    ] */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     ACTIVE [0x2; 0x2] */
    /*     BACKUP [0x1; 0x1] */
    /*     UNAVAILABLE [0x0; 0x0] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_prim_Mapping_EDU1_comStatusSecondary */
    /*     Processing: UNCONDITIONAL */
    /*     Text Mapping */
    /*     SRC -> DST */
    /*     UNAVAILABLE[0x0] -> UNAVAILABLE[0x0] */
    /*     BACKUP[0x1] -> BACKUP[0x1] */
    /*     ACTIVE[0x2] -> ACTIVE[0x2] */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Init temporary-dst-container */
    bus_cpy = 0U;
    //if(GET_u8ComStatusSecondary() == 0U)
    {
        /* Map SRC-Value 'UNAVAILABLE' to DST-Value 'UNAVAILABLE' */
        bus_cpy = 0U;
    }
    //else if(GET_u8ComStatusSecondary() == 1U)
    {
        /* Map SRC-Value 'BACKUP' to DST-Value 'BACKUP' */
        bus_cpy = 1U;
    }
    //else if(GET_u8ComStatusSecondary() == 2U)
    {
        /* Map SRC-Value 'ACTIVE' to DST-Value 'ACTIVE' */
        bus_cpy = 2U;
    }
    //else
    {
        /* SRC is not within the valid COD-range => cancel processing */
        tmp_return_value = ICS_PL_FALSE;
    }
    if(tmp_return_value == ICS_PL_TRUE)
    {
        /* Copy temporary-dst-container to DST */
        if(WRITE_SIGNAL_DATA_API(EDU1_comStatusSecondary, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
        {
            tmp_return_value = ICS_PL_FALSE;
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EDU1_currentDc
/*lint  -efile(451,ipl_hook_tx_prim_mcr.h) */
#include <ipl_hook_tx_prim_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EDU1_currentDc) */
ICS_PL_RETURN_TYPE PL_Cvt_EDU1_currentDc(void)
{
    /* Conversion for TX-Bus-Signal 'EDU1_currentDc' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_S16 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: Pl_HvDcIEstimd(intc_sigcv_tx_prim) */
    /*     Category, Type, Interface: NUM, ICS_PL_FLOAT, VAR */
    /*     Desc: Filtered DC link current */
    /*     Harmonized Physical Range: [-2048...2047.9375] [PD_A] */
    /*     Original Physical Range: [-2048...2047.9375] [A] */
    /*     Variable-Name: Pl_HvDcIEstimd */
    
    /* Destination-Signal Description: */
    /*     Name: EDU1_currentDc(intc_sigcv_tx_prim) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_S16, 10 bits, API */
    /*     Desc: Inverter DC Current" */
    /*     State(s): [0x0...    ] */
    /*     Coded Range: [0xFE02...0x1FE] */
    /*     Harmonized Physical Range: [-510...510] [A] */
    /*     Original Physical Range: [-510...510] [A] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_prim_Mapping_EDU1_currentDc */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Init temporary-dst-container */
    bus_cpy = 0;
    /* Range-Check. Potential violation of SRC.COD_LOWER_LIMIT and SRC.COD_UPPER_LIMIT */
    if((GET_Pl_HvDcIEstimd() <= 2047.9375F) && (GET_Pl_HvDcIEstimd() >= -2048.0F))
    {
        /* Limitation Handling. Potential violation of DST.COD_LOWER_LIMIT */
        if(GET_Pl_HvDcIEstimd() >= -510.0F)
        {
            /* Limitation Handling. Potential violation of DST.COD_UPPER_LIMIT */
            if(GET_Pl_HvDcIEstimd() <= 510.0F)
            {
                ICS_PL_FLOAT temp_float = ((ICS_PL_FLOAT)GET_Pl_HvDcIEstimd());
                bus_cpy = (ICS_PL_S16_ICS_PL_FLOAT)(temp_float);
            }
            else
            {
                /* Automatically limit to DST.COD_UPPER_LIMIT */
                bus_cpy = 510;
            }
        }
        else
        {
            /* Automatically limit to DST.COD_LOWER_LIMIT */
            bus_cpy = ((ICS_PL_S16)-510);
        }
    }
    else
    {
        /* SRC is not within the valid COD-range => cancel processing */
        tmp_return_value = ICS_PL_FALSE;
    }
    if(tmp_return_value == ICS_PL_TRUE)
    {
        /* Copy temporary-dst-container to DST */
        if(WRITE_SIGNAL_DATA_API(EDU1_currentDc, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
        {
            tmp_return_value = ICS_PL_FALSE;
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EDU1_igbtTemp
/*lint  -efile(451,ipl_hook_tx_prim_mcr.h) */
#include <ipl_hook_tx_prim_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EDU1_igbtTemp) */
ICS_PL_RETURN_TYPE PL_Cvt_EDU1_igbtTemp(void)
{
    /* Conversion for TX-Bus-Signal 'EDU1_igbtTemp' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U8 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: Pl_PeIgbtDiodeT(intc_sigcv_tx_prim) */
    /*     Category, Type, Interface: NUM, ICS_PL_FLOAT, VAR */
    /*     Desc: Maximum semiconductor temperature of power switch for inverter */
    /*     Harmonized Physical Range: [-273.15...238.8421875] [degC] */
    /*     Original Physical Range: [0...511.9921875] [K] */
    /*     Variable-Name: Pl_PeIgbtDiodeT */
    
    /* Destination-Signal Description: */
    /*     Name: EDU1_igbtTemp(intc_sigcv_tx_prim) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_U8, 8 bits, API */
    /*     Desc: Max of all the measured igbt temperatures" */
    /*     State(s): [0x0...    ] */
    /*     Coded Range: [0x0...0xFE] */
    /*     Harmonized Physical Range: [-40...214] [degC] */
    /*     Original Physical Range: [-40...214] [degC] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_prim_Mapping_EDU1_igbtTemp */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Init temporary-dst-container */
    bus_cpy = 0U;
    /* Range-Check. Potential violation of SRC.COD_LOWER_LIMIT and SRC.COD_UPPER_LIMIT */
    if((GET_Pl_PeIgbtDiodeT() <= 511.9921875F) && (GET_Pl_PeIgbtDiodeT() >= 0.0F))
    {
        /* Limitation Handling. Potential violation of DST.COD_LOWER_LIMIT */
        if(GET_Pl_PeIgbtDiodeT() >= 233.15F)
        {
            /* Limitation Handling. Potential violation of DST.COD_UPPER_LIMIT */
            if(GET_Pl_PeIgbtDiodeT() <= 487.15F)
            {
                ICS_PL_FLOAT temp_float = ((ICS_PL_FLOAT)GET_Pl_PeIgbtDiodeT() + (ICS_PL_FLOAT)-233.15);
                bus_cpy = (ICS_PL_U8_ICS_PL_FLOAT)(temp_float);
            }
            else
            {
                /* Automatically limit to DST.COD_UPPER_LIMIT */
                bus_cpy = 254U;
            }
        }
        else
        {
            /* Automatically limit to DST.COD_LOWER_LIMIT */
            bus_cpy = 0U;
        }
    }
    else
    {
        /* SRC is not within the valid COD-range => cancel processing */
        tmp_return_value = ICS_PL_FALSE;
    }
    if(tmp_return_value == ICS_PL_TRUE)
    {
        /* Copy temporary-dst-container to DST */
        if(WRITE_SIGNAL_DATA_API(EDU1_igbtTemp, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
        {
            tmp_return_value = ICS_PL_FALSE;
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EDU1_inverterAppBuildType
/*lint  -efile(451,ipl_hook_tx_prim_mcr.h) */
#include <ipl_hook_tx_prim_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EDU1_inverterAppBuildType) */
ICS_PL_RETURN_TYPE PL_Cvt_EDU1_inverterAppBuildType(void)
{
    /* Conversion for TX-Bus-Signal 'EDU1_inverterAppBuildType' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U8 bus_cpy;
    
    
    /* Destination-Signal Description: */
    /*     Name: EDU1_inverterAppBuildType(intc_sigcv_tx_prim) */
    /*     Category, Type, length, Interface: TEXT, ICS_PL_U8, 8 bits, API */
    /*     Desc:  */
    /*     State(s): [0x0...    ] */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     DEV_LOCAL_BUILD_UNTRACKED [0x4; 0x4] */
    /*     DEV_LOCAL_BUILD [0x3; 0x3] */
    /*     DEV_BUILD [0x2; 0x2] */
    /*     RELEASE_BUILD [0x1; 0x1] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_prim_Mapping_EDU1_inverterAppBuildType */
    /*     Processing: STUB */
    /*     Stub-Value: Dst-Signal.USER_VALUE */
    /*     Processing-Value-User-Value: 0x1 */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Stub DST to USER_VALUE */
    bus_cpy = 1U;
    /* Copy temporary-dst-container to DST */
    if(WRITE_SIGNAL_DATA_API(EDU1_inverterAppBuildType, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EDU1_inverterAppChecksum
/*lint  -efile(451,ipl_hook_tx_prim_mcr.h) */
#include <ipl_hook_tx_prim_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EDU1_inverterAppChecksum) */
ICS_PL_RETURN_TYPE PL_Cvt_EDU1_inverterAppChecksum(void)
{
    /* Conversion for TX-Bus-Signal 'EDU1_inverterAppChecksum' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U32 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: u32InverterAppChecksum(intc_sigcv_tx_prim) */
    /*     Category, Type, Interface: NUM, ICS_PL_U32, VAR */
    /*     State(s): [0x0...0x0] */
    /*     Coded Range: [0x00...0xFFFFFFFF] */
    /*     Harmonized Physical Range: [0...4294967295] [] */
    /*     Original Physical Range: [0...4294967295] [] */
    /*     Variable-Name: u32InverterAppChecksum */
    
    /* Destination-Signal Description: */
    /*     Name: EDU1_inverterAppChecksum(intc_sigcv_tx_prim) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_U32, 32 bits, API */
    /*     Desc:  */
    /*     State(s): [0x0...    ] */
    /*     Coded Range: [0x0...0xFFFFFFFF] */
    /*     Harmonized Physical Range: [0...4294967295] [] */
    /*     Original Physical Range: [0...4294967295] [] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_prim_Mapping_EDU1_inverterAppChecksum */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Conversion of 'u32InverterAppChecksum' to 'EDU1_inverterAppChecksum' */
    /*lint -save -e734 */
    bus_cpy = GET_u32InverterAppChecksum();
    /*lint -restore */
    /* Copy temporary-dst-container to DST */
    if(WRITE_SIGNAL_DATA_API(EDU1_inverterAppChecksum, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EDU1_inverterAppInfoMultiplexer_0
/*lint  -efile(451,ipl_hook_tx_prim_mcr.h) */
#include <ipl_hook_tx_prim_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EDU1_inverterAppInfoMultiplexer_0) */
ICS_PL_RETURN_TYPE PL_Cvt_EDU1_inverterAppInfoMultiplexer_0(void)
{
    /* Conversion for TX-Bus-Signal 'EDU1_inverterAppInfoMultiplexer_0' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U8 bus_cpy;
    
    
    /* Destination-Signal Description: */
    /*     Name: EDU1_inverterAppInfoMultiplexer_0(intc_sigcv_tx_prim) */
    /*     Category, Type, length, Interface: TEXT, ICS_PL_U8, 8 bits, API */
    /*     Desc:  */
    /*     State(s): [0x0...0x0] */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     APP_VERSION [0x0; 0x0] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_prim_Mapping_EDU1_inverterAppInfoMultiplexer_0 */
    /*     Processing: STUB */
    /*     Stub-Value: Dst-Signal.INIT */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Stub DST to INIT */
    bus_cpy = 0U;
    /* Copy temporary-dst-container to DST */
    if(WRITE_SIGNAL_DATA_API(EDU1_inverterAppInfoMultiplexer_0, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EDU1_inverterAppInfoMultiplexer_1
/*lint  -efile(451,ipl_hook_tx_prim_mcr.h) */
#include <ipl_hook_tx_prim_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EDU1_inverterAppInfoMultiplexer_1) */
ICS_PL_RETURN_TYPE PL_Cvt_EDU1_inverterAppInfoMultiplexer_1(void)
{
    /* Conversion for TX-Bus-Signal 'EDU1_inverterAppInfoMultiplexer_1' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U8 bus_cpy;
    
    
    /* Destination-Signal Description: */
    /*     Name: EDU1_inverterAppInfoMultiplexer_1(intc_sigcv_tx_prim) */
    /*     Category, Type, length, Interface: TEXT, ICS_PL_U8, 8 bits, API */
    /*     State(s): [0x1...0x1] */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     APP_CHECKSUM [0x1; 0x1] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_prim_Mapping_EDU1_inverterAppInfoMultiplexer_1 */
    /*     Processing: STUB */
    /*     Stub-Value: Dst-Signal.INIT */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Stub DST to INIT */
    bus_cpy = 1U;
    /* Copy temporary-dst-container to DST */
    if(WRITE_SIGNAL_DATA_API(EDU1_inverterAppInfoMultiplexer_1, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EDU1_inverterAppInfoMultiplexer_2
/*lint  -efile(451,ipl_hook_tx_prim_mcr.h) */
#include <ipl_hook_tx_prim_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EDU1_inverterAppInfoMultiplexer_2) */
ICS_PL_RETURN_TYPE PL_Cvt_EDU1_inverterAppInfoMultiplexer_2(void)
{
    /* Conversion for TX-Bus-Signal 'EDU1_inverterAppInfoMultiplexer_2' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U8 bus_cpy;
    
    
    /* Destination-Signal Description: */
    /*     Name: EDU1_inverterAppInfoMultiplexer_2(intc_sigcv_tx_prim) */
    /*     Category, Type, length, Interface: TEXT, ICS_PL_U8, 8 bits, API */
    /*     State(s): [0x2...0x2] */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     ECU_CONFIG [0x2; 0x2] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_prim_Mapping_EDU1_inverterAppInfoMultiplexer_2 */
    /*     Processing: STUB */
    /*     Stub-Value: Dst-Signal.INIT */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Stub DST to INIT */
    bus_cpy = 2U;
    /* Copy temporary-dst-container to DST */
    if(WRITE_SIGNAL_DATA_API(EDU1_inverterAppInfoMultiplexer_2, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EDU1_inverterAppVersionMajor
/*lint  -efile(451,ipl_hook_tx_prim_mcr.h) */
#include <ipl_hook_tx_prim_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EDU1_inverterAppVersionMajor) */
ICS_PL_RETURN_TYPE PL_Cvt_EDU1_inverterAppVersionMajor(void)
{
    /* Conversion for TX-Bus-Signal 'EDU1_inverterAppVersionMajor' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U8 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: ecu_id_sw_idx[9](intc_sigcv_tx_prim) */
    /*     Category, Type, Interface: NUM, ICS_PL_U8, VAR */
    /*     Coded Range: [0x00...0xFF] */
    /*     Harmonized Physical Range: [-48...207] [] */
    /*     Original Physical Range: [0...255] [] */
    /*     Variable-Name: ecu_id_sw_idx[5] */
    
    /* Destination-Signal Description: */
    /*     Name: EDU1_inverterAppVersionMajor(intc_sigcv_tx_prim) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_U8, 8 bits, API */
    /*     Desc:  */
    /*     State(s): [0x0...    ] */
    /*     Coded Range: [0x0...0xFF] */
    /*     Harmonized Physical Range: [0...255] [NoUnit] */
    /*     Original Physical Range: [0...255] [NoUnit] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_prim_Mapping_EDU1_inverterAppVersionMajor */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Init temporary-dst-container */
    bus_cpy = 0U;
    /* Limitation Handling. Potential violation of DST.COD_LOWER_LIMIT */
    if(GET_ecu_id_sw_idx(5) >= 48U)
    {
        /* Conversion of 'ecu_id_sw_idx' to 'EDU1_inverterAppVersionMajor' */
        /*lint -save -e734 */
        bus_cpy = GET_ecu_id_sw_idx(5)-48U;
        /*lint -restore */
    }
    else
    {
        /* Automatically limit to DST.COD_LOWER_LIMIT */
        bus_cpy = 0U;
    }
    /* Copy temporary-dst-container to DST */
    if(WRITE_SIGNAL_DATA_API(EDU1_inverterAppVersionMajor, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EDU1_inverterAppVersionMinor
/*lint  -efile(451,ipl_hook_tx_prim_mcr.h) */
#include <ipl_hook_tx_prim_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EDU1_inverterAppVersionMinor) */
ICS_PL_RETURN_TYPE PL_Cvt_EDU1_inverterAppVersionMinor(void)
{
    /* Conversion for TX-Bus-Signal 'EDU1_inverterAppVersionMinor' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U8 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: ecu_id_sw_idx[9](intc_sigcv_tx_prim) */
    /*     Category, Type, Interface: NUM, ICS_PL_U8, VAR */
    /*     Coded Range: [0x00...0xFF] */
    /*     Harmonized Physical Range: [-48...207] [] */
    /*     Original Physical Range: [0...255] [] */
    /*     Variable-Name: ecu_id_sw_idx[6] */
    
    /* Destination-Signal Description: */
    /*     Name: EDU1_inverterAppVersionMinor(intc_sigcv_tx_prim) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_U8, 8 bits, API */
    /*     Desc:  */
    /*     State(s): [0x0...    ] */
    /*     Coded Range: [0x0...0xFF] */
    /*     Harmonized Physical Range: [0...255] [NoUnit] */
    /*     Original Physical Range: [0...255] [NoUnit] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_prim_Mapping_EDU1_inverterAppVersionMinor */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Init temporary-dst-container */
    bus_cpy = 0U;
    /* Limitation Handling. Potential violation of DST.COD_LOWER_LIMIT */
    if(GET_ecu_id_sw_idx(6) >= 48U)
    {
        /* Conversion of 'ecu_id_sw_idx' to 'EDU1_inverterAppVersionMinor' */
        /*lint -save -e734 */
        bus_cpy = GET_ecu_id_sw_idx(6)-48U;
        /*lint -restore */
    }
    else
    {
        /* Automatically limit to DST.COD_LOWER_LIMIT */
        bus_cpy = 0U;
    }
    /* Copy temporary-dst-container to DST */
    if(WRITE_SIGNAL_DATA_API(EDU1_inverterAppVersionMinor, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EDU1_inverterAppVersionRev
/*lint  -efile(451,ipl_hook_tx_prim_mcr.h) */
#include <ipl_hook_tx_prim_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EDU1_inverterAppVersionRev) */
ICS_PL_RETURN_TYPE PL_Cvt_EDU1_inverterAppVersionRev(void)
{
    /* Conversion for TX-Bus-Signal 'EDU1_inverterAppVersionRev' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U8 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: ecu_id_sw_idx[9](intc_sigcv_tx_prim) */
    /*     Category, Type, Interface: NUM, ICS_PL_U8, VAR */
    /*     Coded Range: [0x00...0xFF] */
    /*     Harmonized Physical Range: [-48...207] [] */
    /*     Original Physical Range: [0...255] [] */
    /*     Variable-Name: ecu_id_sw_idx[7] */
    
    /* Destination-Signal Description: */
    /*     Name: EDU1_inverterAppVersionRev(intc_sigcv_tx_prim) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_U8, 8 bits, API */
    /*     Desc:  */
    /*     State(s): [0x0...    ] */
    /*     Coded Range: [0x0...0xFF] */
    /*     Harmonized Physical Range: [0...255] [NoUnit] */
    /*     Original Physical Range: [0...255] [NoUnit] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_prim_Mapping_EDU1_inverterAppVersionRev */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Init temporary-dst-container */
    bus_cpy = 0U;
    /* Limitation Handling. Potential violation of DST.COD_LOWER_LIMIT */
    if(GET_ecu_id_sw_idx(7) >= 48U)
    {
        /* Conversion of 'ecu_id_sw_idx' to 'EDU1_inverterAppVersionRev' */
        /*lint -save -e734 */
        bus_cpy = GET_ecu_id_sw_idx(7)-48U;
        /*lint -restore */
    }
    else
    {
        /* Automatically limit to DST.COD_LOWER_LIMIT */
        bus_cpy = 0U;
    }
    /* Copy temporary-dst-container to DST */
    if(WRITE_SIGNAL_DATA_API(EDU1_inverterAppVersionRev, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EDU1_inverterBootInfoVersionRev
/*lint  -efile(451,ipl_hook_tx_prim_mcr.h) */
#include <ipl_hook_tx_prim_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EDU1_inverterBootInfoVersionRev) */
ICS_PL_RETURN_TYPE PL_Cvt_EDU1_inverterBootInfoVersionRev(void)
{
    /* Conversion for TX-Bus-Signal 'EDU1_inverterBootInfoVersionRev' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U8 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: u8InverterBootInfoVersionRev(intc_sigcv_tx_prim) */
    /*     Category, Type, Interface: NUM, ICS_PL_U8, VAR */
    /*     State(s): [0x0...0x0] */
    /*     Coded Range: [0x00...0xFF] */
    /*     Harmonized Physical Range: [0...255] [] */
    /*     Original Physical Range: [0...255] [] */
    /*     Variable-Name: u8InverterBootInfoVersionRev */
    
    /* Destination-Signal Description: */
    /*     Name: EDU1_inverterBootInfoVersionRev(intc_sigcv_tx_prim) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_U8, 8 bits, API */
    /*     Desc:  */
    /*     State(s): [0x0...    ] */
    /*     Coded Range: [0x0...0xFF] */
    /*     Harmonized Physical Range: [0...255] [NoUnit] */
    /*     Original Physical Range: [0...255] [NoUnit] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_prim_Mapping_EDU1_inverterBootInfoVersionRev */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Conversion of 'u8InverterBootInfoVersionRev' to 'EDU1_inverterBootInfoVersionRev' */
    /*lint -save -e734 */
    bus_cpy = GET_u8InverterBootInfoVersionRev();
    /*lint -restore */
    /* Copy temporary-dst-container to DST */
    if(WRITE_SIGNAL_DATA_API(EDU1_inverterBootInfoVersionRev, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EDU1_inverterBootInfoVersnMajor
/*lint  -efile(451,ipl_hook_tx_prim_mcr.h) */
#include <ipl_hook_tx_prim_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EDU1_inverterBootInfoVersnMajor) */
ICS_PL_RETURN_TYPE PL_Cvt_EDU1_inverterBootInfoVersnMajor(void)
{
    /* Conversion for TX-Bus-Signal 'EDU1_inverterBootInfoVersnMajor' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U8 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: u8InverterBootInfoVersnMajor(intc_sigcv_tx_prim) */
    /*     Category, Type, Interface: NUM, ICS_PL_U8, VAR */
    /*     State(s): [0x0...0x0] */
    /*     Coded Range: [0x00...0xFF] */
    /*     Harmonized Physical Range: [0...255] [] */
    /*     Original Physical Range: [0...255] [] */
    /*     Variable-Name: u8InverterBootInfoVersnMajor */
    
    /* Destination-Signal Description: */
    /*     Name: EDU1_inverterBootInfoVersnMajor(intc_sigcv_tx_prim) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_U8, 8 bits, API */
    /*     Desc:  */
    /*     State(s): [0x0...    ] */
    /*     Coded Range: [0x0...0xFF] */
    /*     Harmonized Physical Range: [0...255] [NoUnit] */
    /*     Original Physical Range: [0...255] [NoUnit] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_prim_Mapping_EDU1_inverterBootInfoVersnMajor */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Conversion of 'u8InverterBootInfoVersnMajor' to 'EDU1_inverterBootInfoVersnMajor' */
    /*lint -save -e734 */
    bus_cpy = GET_u8InverterBootInfoVersnMajor();
    /*lint -restore */
    /* Copy temporary-dst-container to DST */
    if(WRITE_SIGNAL_DATA_API(EDU1_inverterBootInfoVersnMajor, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EDU1_inverterBootInfoVersnMinor
/*lint  -efile(451,ipl_hook_tx_prim_mcr.h) */
#include <ipl_hook_tx_prim_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EDU1_inverterBootInfoVersnMinor) */
ICS_PL_RETURN_TYPE PL_Cvt_EDU1_inverterBootInfoVersnMinor(void)
{
    /* Conversion for TX-Bus-Signal 'EDU1_inverterBootInfoVersnMinor' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U8 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: u8InverterBootInfoVersnMinor(intc_sigcv_tx_prim) */
    /*     Category, Type, Interface: NUM, ICS_PL_U8, VAR */
    /*     State(s): [0x0...0x0] */
    /*     Coded Range: [0x00...0xFF] */
    /*     Harmonized Physical Range: [0...255] [] */
    /*     Original Physical Range: [0...255] [] */
    /*     Variable-Name: u8InverterBootInfoVersnMinor */
    
    /* Destination-Signal Description: */
    /*     Name: EDU1_inverterBootInfoVersnMinor(intc_sigcv_tx_prim) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_U8, 8 bits, API */
    /*     Desc:  */
    /*     State(s): [0x0...    ] */
    /*     Coded Range: [0x0...0xFF] */
    /*     Harmonized Physical Range: [0...255] [NoUnit] */
    /*     Original Physical Range: [0...255] [NoUnit] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_prim_Mapping_EDU1_inverterBootInfoVersnMinor */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Conversion of 'u8InverterBootInfoVersnMinor' to 'EDU1_inverterBootInfoVersnMinor' */
    /*lint -save -e734 */
    bus_cpy = GET_u8InverterBootInfoVersnMinor();
    /*lint -restore */
    /* Copy temporary-dst-container to DST */
    if(WRITE_SIGNAL_DATA_API(EDU1_inverterBootInfoVersnMinor, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EDU1_inverterComponentId
/*lint  -efile(451,ipl_hook_tx_prim_mcr.h) */
#include <ipl_hook_tx_prim_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EDU1_inverterComponentId) */
ICS_PL_RETURN_TYPE PL_Cvt_EDU1_inverterComponentId(void)
{
    /* Conversion for TX-Bus-Signal 'EDU1_inverterComponentId' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U16 bus_cpy;
    
    
    /* Destination-Signal Description: */
    /*     Name: EDU1_inverterComponentId(intc_sigcv_tx_prim) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_U16, 16 bits, API */
    /*     Desc:  */
    /*     State(s): [0x0...    ] */
    /*     Coded Range: [0x0...0xFFFF] */
    /*     Harmonized Physical Range: [0...65535] [] */
    /*     Original Physical Range: [0...65535] [] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_prim_Mapping_EDU1_inverterComponentId */
    /*     Processing: STUB */
    /*     Stub-Value: Dst-Signal.USER_VALUE */
    /*     Processing-Value-User-Value: 0x11 */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Stub DST to USER_VALUE */
    bus_cpy = 17U;
    /* Copy temporary-dst-container to DST */
    if(WRITE_SIGNAL_DATA_API(EDU1_inverterComponentId, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EDU1_inverterHardwareId
/*lint  -efile(451,ipl_hook_tx_prim_mcr.h) */
#include <ipl_hook_tx_prim_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EDU1_inverterHardwareId) */
ICS_PL_RETURN_TYPE PL_Cvt_EDU1_inverterHardwareId(void)
{
    /* Conversion for TX-Bus-Signal 'EDU1_inverterHardwareId' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U8 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: HwSample(intc_sigcv_tx_prim) */
    /*     Category, Type, Interface: NUM, ICS_PL_U8, VAR */
    /*     State(s): [0x0...0x0] */
    /*     Coded Range: [0x00...0x0F] */
    /*     Harmonized Physical Range: [0...15] [] */
    /*     Original Physical Range: [0...15] [] */
    /*     Variable-Name: HwSample */
    
    /* Destination-Signal Description: */
    /*     Name: EDU1_inverterHardwareId(intc_sigcv_tx_prim) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_U8, 8 bits, API */
    /*     Desc:  */
    /*     State(s): [0x0...    ] */
    /*     Coded Range: [0x0...0x0F] */
    /*     Harmonized Physical Range: [0...15] [NoUnit] */
    /*     Original Physical Range: [0...15] [NoUnit] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_prim_Mapping_EDU1_inverterHardwareId */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Init temporary-dst-container */
    bus_cpy = 0U;
    /* Range-Check. Potential violation of SRC.COD_UPPER_LIMIT */
    if(GET_HwSample() <= 15U)
    {
        /* Conversion of 'HwSample' to 'EDU1_inverterHardwareId' */
        /*lint -save -e734 */
        bus_cpy = GET_HwSample();
        /*lint -restore */
    }
    else
    {
        /* SRC is not within the valid COD-range => cancel processing */
        tmp_return_value = ICS_PL_FALSE;
    }
    if(tmp_return_value == ICS_PL_TRUE)
    {
        /* Copy temporary-dst-container to DST */
        if(WRITE_SIGNAL_DATA_API(EDU1_inverterHardwareId, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
        {
            tmp_return_value = ICS_PL_FALSE;
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EDU1_inverterInstanceId
/*lint  -efile(451,ipl_hook_tx_prim_mcr.h) */
#include <ipl_hook_tx_prim_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EDU1_inverterInstanceId) */
ICS_PL_RETURN_TYPE PL_Cvt_EDU1_inverterInstanceId(void)
{
    /* Conversion for TX-Bus-Signal 'EDU1_inverterInstanceId' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U8 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: u8PostbuildVariantSelected(intc_sigcv_tx_prim) */
    /*     Category, Type, Interface: TEXT, ICS_PL_U8, VAR */
    /*     State(s): [0x0...0x0] */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     EVAL_CALIBRATION [0x0; 0x0] */
    /*     FRONT_DEVELOPER_VALUE [0x1; 0x1] */
    /*     REAR_DEVELOPER_VALUE [0x2; 0x2] */
    /*     ERROR_DEVELOPER_VALUE [0xFF; 0xFF] */
    /*     Variable-Name: u8PostbuildVariantSelected */
    
    /* Destination-Signal Description: */
    /*     Name: EDU1_inverterInstanceId(intc_sigcv_tx_prim) */
    /*     Category, Type, length, Interface: TEXT, ICS_PL_U8, 8 bits, API */
    /*     Desc:  */
    /*     State(s): [0x0...    ] */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     init [0x0; 0x0] */
    /*     north EDU [0x1; 0x1] */
    /*     south EDU [0x2; 0x2] */
    /*     unkown [0x3; 0x3] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_prim_Mapping_EDU1_inverterInstanceId */
    /*     Processing: UNCONDITIONAL */
    /*     Text Mapping */
    /*     SRC -> DST */
    /*     EVAL_CALIBRATION[0x0] -> init[0x0] */
    /*     FRONT_DEVELOPER_VALUE[0x1] -> north EDU[0x1] */
    /*     REAR_DEVELOPER_VALUE[0x2] -> south EDU[0x2] */
    /*     ERROR_DEVELOPER_VALUE[0xFF] -> unkown[0x3] */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Init temporary-dst-container */
    bus_cpy = 0U;
    if(GET_u8PostbuildVariantSelected() == 0U)
    {
        /* Map SRC-Value 'EVAL_CALIBRATION' to DST-Value 'init' */
        bus_cpy = 0U;
    }
    else if(GET_u8PostbuildVariantSelected() == 1U)
    {
        /* Map SRC-Value 'FRONT_DEVELOPER_VALUE' to DST-Value 'north EDU' */
        bus_cpy = 1U;
    }
    else if(GET_u8PostbuildVariantSelected() == 2U)
    {
        /* Map SRC-Value 'REAR_DEVELOPER_VALUE' to DST-Value 'south EDU' */
        bus_cpy = 2U;
    }
    else if(GET_u8PostbuildVariantSelected() == 255U)
    {
        /* Map SRC-Value 'ERROR_DEVELOPER_VALUE' to DST-Value 'unkown' */
        bus_cpy = 3U;
    }
    else
    {
        /* SRC is not within the valid COD-range => cancel processing */
        tmp_return_value = ICS_PL_FALSE;
    }
    if(tmp_return_value == ICS_PL_TRUE)
    {
        /* Copy temporary-dst-container to DST */
        if(WRITE_SIGNAL_DATA_API(EDU1_inverterInstanceId, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
        {
            tmp_return_value = ICS_PL_FALSE;
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EDU1_inverterState
/*lint  -efile(451,ipl_hook_tx_prim_mcr.h) */
#include <ipl_hook_tx_prim_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EDU1_inverterState) */
ICS_PL_RETURN_TYPE PL_Cvt_EDU1_inverterState(void)
{
    /* Conversion for TX-Bus-Signal 'EDU1_inverterState' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U8 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: Pl_PeModeAct(intc_sigcv_tx_prim) */
    /*     Category, Type, Interface: TEXT, ICS_PL_U8, VAR */
    /*     Desc: Actual inverter mode reported back to vehicle */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     FCT_RDY [0x0; 0x0] */
    /*     COM_RDY [0x1; 0x1] */
    /*     TQ_CTL [0x2; 0x2] */
    /*     N_CTL [0x3; 0x3] */
    /*     SHO_ACT [0x4; 0x4] */
    /*     POSN_CAL [0x5; 0x5] */
    /*     ERR [0x6; 0x6] */
    /*     CTL_DCHA_DCV [0x7; 0x7] */
    /*     Variable-Name: Pl_PeModeAct */
    
    /* Destination-Signal Description: */
    /*     Name: EDU1_inverterState(intc_sigcv_tx_prim) */
    /*     Category, Type, length, Interface: TEXT, ICS_PL_U8, 4 bits, API */
    /*     Desc: Inverter State" */
    /*     State(s): [0x0...    ] */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     ACTIVE_DISCHARGE [0x7; 0x7] */
    /*     FAULT [0x6; 0x6] */
    /*     CALIBRATION [0x5; 0x5] */
    /*     ACTIVE_SHORT_CIRCUIT [0x4; 0x4] */
    /*     SPEED_CONTROL [0x3; 0x3] */
    /*     TORQUE_CONTROL [0x2; 0x2] */
    /*     COM_READY [0x1; 0x1] */
    /*     FUNCTION_READY [0x0; 0x0] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_prim_Mapping_EDU1_inverterState */
    /*     Processing: UNCONDITIONAL */
    /*     Text Mapping */
    /*     SRC -> DST */
    /*     FCT_RDY[0x0] -> FUNCTION_READY[0x0] */
    /*     COM_RDY[0x1] -> COM_READY[0x1] */
    /*     TQ_CTL[0x2] -> TORQUE_CONTROL[0x2] */
    /*     N_CTL[0x3] -> SPEED_CONTROL[0x3] */
    /*     SHO_ACT[0x4] -> ACTIVE_SHORT_CIRCUIT[0x4] */
    /*     POSN_CAL[0x5] -> CALIBRATION[0x5] */
    /*     ERR[0x6] -> FAULT[0x6] */
    /*     CTL_DCHA_DCV[0x7] -> ACTIVE_DISCHARGE[0x7] */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Init temporary-dst-container */
    bus_cpy = 0U;
    if(GET_Pl_PeModeAct() == 0U)
    {
        /* Map SRC-Value 'FCT_RDY' to DST-Value 'FUNCTION_READY' */
        bus_cpy = 0U;
    }
    else if(GET_Pl_PeModeAct() == 1U)
    {
        /* Map SRC-Value 'COM_RDY' to DST-Value 'COM_READY' */
        bus_cpy = 1U;
    }
    else if(GET_Pl_PeModeAct() == 2U)
    {
        /* Map SRC-Value 'TQ_CTL' to DST-Value 'TORQUE_CONTROL' */
        bus_cpy = 2U;
    }
    else if(GET_Pl_PeModeAct() == 3U)
    {
        /* Map SRC-Value 'N_CTL' to DST-Value 'SPEED_CONTROL' */
        bus_cpy = 3U;
    }
    else if(GET_Pl_PeModeAct() == 4U)
    {
        /* Map SRC-Value 'SHO_ACT' to DST-Value 'ACTIVE_SHORT_CIRCUIT' */
        bus_cpy = 4U;
    }
    else if(GET_Pl_PeModeAct() == 5U)
    {
        /* Map SRC-Value 'POSN_CAL' to DST-Value 'CALIBRATION' */
        bus_cpy = 5U;
    }
    else if(GET_Pl_PeModeAct() == 6U)
    {
        /* Map SRC-Value 'ERR' to DST-Value 'FAULT' */
        bus_cpy = 6U;
    }
    else if(GET_Pl_PeModeAct() == 7U)
    {
        /* Map SRC-Value 'CTL_DCHA_DCV' to DST-Value 'ACTIVE_DISCHARGE' */
        bus_cpy = 7U;
    }
    else
    {
        /* SRC is not within the valid COD-range => cancel processing */
        tmp_return_value = ICS_PL_FALSE;
    }
    if(tmp_return_value == ICS_PL_TRUE)
    {
        /* Copy temporary-dst-container to DST */
        if(WRITE_SIGNAL_DATA_API(EDU1_inverterState, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
        {
            tmp_return_value = ICS_PL_FALSE;
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EDU1_nmAbleToSleep
/*lint  -efile(451,ipl_hook_tx_prim_mcr.h) */
#include <ipl_hook_tx_prim_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EDU1_nmAbleToSleep) */
ICS_PL_RETURN_TYPE PL_Cvt_EDU1_nmAbleToSleep(void)
{
    /* Conversion for TX-Bus-Signal 'EDU1_nmAbleToSleep' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_FLAG bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: bNmAbleToSleep(intc_sigcv_tx_prim) */
    /*     Category, Type, Interface: TEXT, ICS_PL_FLAG, VAR */
    /*     State(s): [0x0...0x0] */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     FALSE [0x0; 0x0] */
    /*     TRUE [0x1; 0x1] */
    /*     Variable-Name: bNmAbleToSleep */
    
    /* Destination-Signal Description: */
    /*     Name: EDU1_nmAbleToSleep(intc_sigcv_tx_prim) */
    /*     Category, Type, length, Interface: TEXT, ICS_PL_FLAG, 1 bits, API */
    /*     Desc:  */
    /*     State(s): [0x0...0x0] */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     UnableToSleep [0x0; 0x0] */
    /*     AbleToSleep [0x1; 0x1] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_prim_Mapping_EDU1_nmAbleToSleep */
    /*     Processing: UNCONDITIONAL */
    /*     Text Mapping */
    /*     SRC -> DST */
    /*     FALSE[0x0] -> UnableToSleep[0x0] */
    /*     TRUE[0x1] -> AbleToSleep[0x1] */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    if(GET_bNmAbleToSleep() == ICS_PL_FALSE)
    {
        /* Map SRC-Value 'FALSE' to DST-Value 'UnableToSleep' */
        bus_cpy = ICS_PL_FALSE;
    }
    else
    {
        /* Map SRC-Value 'TRUE' to DST-Value 'AbleToSleep' */
        bus_cpy = ICS_PL_TRUE;
    }
    /* Copy temporary-dst-container to DST */
    if(WRITE_SIGNAL_DATA_API(EDU1_nmAbleToSleep, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EDU1_nmSleepError
/*lint  -efile(451,ipl_hook_tx_prim_mcr.h) */
#include <ipl_hook_tx_prim_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EDU1_nmSleepError) */
ICS_PL_RETURN_TYPE PL_Cvt_EDU1_nmSleepError(void)
{
    /* Conversion for TX-Bus-Signal 'EDU1_nmSleepError' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U8 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: bNmAbleToSleep(intc_sigcv_tx_prim) */
    /*     Category, Type, Interface: TEXT, ICS_PL_FLAG, VAR */
    /*     State(s): [0x0...0x0] */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     FALSE [0x0; 0x0] */
    /*     TRUE [0x1; 0x1] */
    /*     Variable-Name: bNmAbleToSleep */
    
    /* Destination-Signal Description: */
    /*     Name: EDU1_nmSleepError(intc_sigcv_tx_prim) */
    /*     Category, Type, length, Interface: TEXT, ICS_PL_U8, 4 bits, API */
    /*     Desc:  */
    /*     State(s): [0x0...    ] */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     ECU_Specific_15 [0xF; 0xF] */
    /*     ECU_Specific_14 [0xE; 0xE] */
    /*     ECU_Specific_13 [0xD; 0xD] */
    /*     ECU_Specific_12 [0xC; 0xC] */
    /*     ECU_Specific_11 [0xB; 0xB] */
    /*     ECU_Specific_10 [0xA; 0xA] */
    /*     ECU_Specific_9 [0x9; 0x9] */
    /*     ECU_Specific_8 [0x8; 0x8] */
    /*     ECU_Specific_7 [0x7; 0x7] */
    /*     ECU_Specific_6 [0x6; 0x6] */
    /*     ECU_Specific_5 [0x5; 0x5] */
    /*     ECU_Specific_4 [0x4; 0x4] */
    /*     ECU_Specific_3 [0x3; 0x3] */
    /*     ECU_Specific_2 [0x2; 0x2] */
    /*     ECU_Specific_1 [0x1; 0x1] */
    /*     NONE [0x0; 0x0] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_prim_Mapping_EDU1_nmSleepError */
    /*     Processing: UNCONDITIONAL */
    /*     Text Mapping */
    /*     SRC -> DST */
    /*     FALSE[0x0] -> ECU_Specific_1[0x1] */
    /*     TRUE[0x1] -> NONE[0x0] */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    if(GET_bNmAbleToSleep() == ICS_PL_FALSE)
    {
        /* Map SRC-Value 'FALSE' to DST-Value 'ECU_Specific_1' */
        bus_cpy = 1U;
    }
    else
    {
        /* Map SRC-Value 'TRUE' to DST-Value 'NONE' */
        bus_cpy = 0U;
    }
    /* Copy temporary-dst-container to DST */
    if(WRITE_SIGNAL_DATA_API(EDU1_nmSleepError, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EDU1_nmState
/*lint  -efile(451,ipl_hook_tx_prim_mcr.h) */
#include <ipl_hook_tx_prim_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EDU1_nmState) */
ICS_PL_RETURN_TYPE PL_Cvt_EDU1_nmState(void)
{
    /* Conversion for TX-Bus-Signal 'EDU1_nmState' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U8 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: eCanNmState(intc_sigcv_tx_prim) */
    /*     Category, Type, Interface: TEXT, ICS_PL_U8, VAR */
    /* Desc: Datatype "U8" is expected to be OK for an enumeration variable since memory access to a single */
    /* byte should always be OK (no alignment error) even if the enumeration variable might be stored as a */
    /* wider type (e. g. 32 bit wide via the compiler option "--integer-enumeration"). */
    /*     State(s): [0x01...0x01] */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     CAN_NM_STARTUP [0x0; 0x0] */
    /*     CAN_NM_INIT [0x1; 0x1] */
    /*     CAN_NM_NORMAL_OPERATION [0x2; 0x2] */
    /*     CAN_NM_CAN_QUIET [0x3; 0x3] */
    /*     CAN_NM_SHUTDOWN [0x4; 0x4] */
    /*     CAN_NM_LOW_POWER [0x5; 0x5] */
    /*     Variable-Name: eCanNmState */
    
    /* Destination-Signal Description: */
    /*     Name: EDU1_nmState(intc_sigcv_tx_prim) */
    /*     Category, Type, length, Interface: TEXT, ICS_PL_U8, 3 bits, API */
    /*     Desc:  */
    /*     State(s): [0x0...    ] */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     SLEEP [0x5; 0x5] */
    /*     NORMAL_OPERATION [0x1; 0x1] */
    /*     INVALID [0x0; 0x0] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_prim_Mapping_EDU1_nmState */
    /*     Processing: UNCONDITIONAL */
    /*     Text Mapping */
    /*     SRC -> DST */
    /*     CAN_NM_STARTUP[0x0] -> INVALID[0x0] */
    /*     CAN_NM_INIT[0x1] -> INVALID[0x0] */
    /*     CAN_NM_NORMAL_OPERATION[0x2] -> NORMAL_OPERATION[0x1] */
    /*     CAN_NM_CAN_QUIET[0x3] -> SLEEP[0x5] */
    /*     CAN_NM_SHUTDOWN[0x4] -> SLEEP[0x5] */
    /*     CAN_NM_LOW_POWER[0x5] -> SLEEP[0x5] */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Init temporary-dst-container */
    bus_cpy = 0U;
    if(GET_eCanNmState() == 0U)
    {
        /* Map SRC-Value 'CAN_NM_STARTUP' to DST-Value 'INVALID' */
        bus_cpy = 0U;
    }
    else if(GET_eCanNmState() == 1U)
    {
        /* Map SRC-Value 'CAN_NM_INIT' to DST-Value 'INVALID' */
        bus_cpy = 0U;
    }
    else if(GET_eCanNmState() == 2U)
    {
        /* Map SRC-Value 'CAN_NM_NORMAL_OPERATION' to DST-Value 'NORMAL_OPERATION' */
        bus_cpy = 1U;
    }
    else if(GET_eCanNmState() == 3U)
    {
        /* Map SRC-Value 'CAN_NM_CAN_QUIET' to DST-Value 'SLEEP' */
        bus_cpy = 5U;
    }
    else if(GET_eCanNmState() == 4U)
    {
        /* Map SRC-Value 'CAN_NM_SHUTDOWN' to DST-Value 'SLEEP' */
        bus_cpy = 5U;
    }
    else if(GET_eCanNmState() == 5U)
    {
        /* Map SRC-Value 'CAN_NM_LOW_POWER' to DST-Value 'SLEEP' */
        bus_cpy = 5U;
    }
    else
    {
        /* SRC is not within the valid COD-range => cancel processing */
        tmp_return_value = ICS_PL_FALSE;
    }
    if(tmp_return_value == ICS_PL_TRUE)
    {
        /* Copy temporary-dst-container to DST */
        if(WRITE_SIGNAL_DATA_API(EDU1_nmState, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
        {
            tmp_return_value = ICS_PL_FALSE;
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EDU1_outputShaftTorque
/*lint  -efile(451,ipl_hook_tx_prim_mcr.h) */
#include <ipl_hook_tx_prim_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EDU1_outputShaftTorque) */
ICS_PL_RETURN_TYPE PL_Cvt_EDU1_outputShaftTorque(void)
{
    /* Conversion for TX-Bus-Signal 'EDU1_outputShaftTorque' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_S16 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: Pl_WhlTqEstimdAct(intc_sigcv_tx_prim) */
    /*     Category, Type, Interface: NUM, ICS_PL_FLOAT, VAR */
    /*     Desc: Actual available torque at wheels considering limitation of electrical machine. */
    /*     Harmonized Physical Range: [-4096...4095.875] [PD_Nm] */
    /*     Original Physical Range: [-4096...4095.875] [Nm] */
    /*     Variable-Name: Pl_WhlTqEstimdAct */
    
    /* Destination-Signal Description: */
    /*     Name: EDU1_outputShaftTorque(intc_sigcv_tx_prim) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_S16, 13 bits, API */
    /*     Desc: Torque at the Output Shaft" */
    /*     State(s): [0x0...    ] */
    /*     Coded Range: [0xF4AC...0xB54] */
    /*     Harmonized Physical Range: [-2900...2900] [Nm] */
    /*     Original Physical Range: [-2900...2900] [Nm] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_prim_Mapping_EDU1_outputShaftTorque */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Init temporary-dst-container */
    bus_cpy = 0;
    /* Range-Check. Potential violation of SRC.COD_LOWER_LIMIT and SRC.COD_UPPER_LIMIT */
    if((GET_Pl_WhlTqEstimdAct() <= 4095.875F) && (GET_Pl_WhlTqEstimdAct() >= -4096.0F))
    {
        /* Limitation Handling. Potential violation of DST.COD_LOWER_LIMIT */
        if(GET_Pl_WhlTqEstimdAct() >= -2900.0F)
        {
            /* Limitation Handling. Potential violation of DST.COD_UPPER_LIMIT */
            if(GET_Pl_WhlTqEstimdAct() <= 2900.0F)
            {
                ICS_PL_FLOAT temp_float = ((ICS_PL_FLOAT)GET_Pl_WhlTqEstimdAct());
                bus_cpy = (ICS_PL_S16_ICS_PL_FLOAT)(temp_float);
            }
            else
            {
                /* Automatically limit to DST.COD_UPPER_LIMIT */
                bus_cpy = 2900;
            }
        }
        else
        {
            /* Automatically limit to DST.COD_LOWER_LIMIT */
            bus_cpy = ((ICS_PL_S16)-2900);
        }
    }
    else
    {
        /* SRC is not within the valid COD-range => cancel processing */
        tmp_return_value = ICS_PL_FALSE;
    }
    if(tmp_return_value == ICS_PL_TRUE)
    {
        /* Copy temporary-dst-container to DST */
        if(WRITE_SIGNAL_DATA_API(EDU1_outputShaftTorque, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
        {
            tmp_return_value = ICS_PL_FALSE;
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EDU1_outputShaftTorqueLimMax
/*lint  -efile(451,ipl_hook_tx_prim_mcr.h) */
#include <ipl_hook_tx_prim_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EDU1_outputShaftTorqueLimMax) */
ICS_PL_RETURN_TYPE PL_Cvt_EDU1_outputShaftTorqueLimMax(void)
{
    /* Conversion for TX-Bus-Signal 'EDU1_outputShaftTorqueLimMax' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U16 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: Pl_WhlTqMaxEstimdLimAct(intc_sigcv_tx_prim) */
    /*     Category, Type, Interface: NUM, ICS_PL_FLOAT, VAR */
    /*     Desc: Maximum available torque at wheels considering limitation of electrical machine. */
    /*     Harmonized Physical Range: [-4096...4095.875] [PD_Nm] */
    /*     Original Physical Range: [-4096...4095.875] [Nm] */
    /*     Variable-Name: Pl_WhlTqMaxEstimdLimAct */
    
    /* Destination-Signal Description: */
    /*     Name: EDU1_outputShaftTorqueLimMax(intc_sigcv_tx_prim) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_U16, 13 bits, API */
    /*     Desc: Torque Limit in the EDU's forward direction" */
    /*     State(s): [0x0...    ] */
    /*     Coded Range: [0x0...0xB54] */
    /*     Harmonized Physical Range: [0...2900] [Nm] */
    /*     Original Physical Range: [0...2900] [Nm] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_prim_Mapping_EDU1_outputShaftTorqueLimMax */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Init temporary-dst-container */
    bus_cpy = 0U;
    /* Range-Check. Potential violation of SRC.COD_LOWER_LIMIT and SRC.COD_UPPER_LIMIT */
    if((GET_Pl_WhlTqMaxEstimdLimAct() <= 4095.875F) && (GET_Pl_WhlTqMaxEstimdLimAct() >= -4096.0F))
    {
        /* Limitation Handling. Potential violation of DST.COD_LOWER_LIMIT */
        if(GET_Pl_WhlTqMaxEstimdLimAct() >= 0.0F)
        {
            /* Limitation Handling. Potential violation of DST.COD_UPPER_LIMIT */
            if(GET_Pl_WhlTqMaxEstimdLimAct() <= 2900.0F)
            {
                ICS_PL_FLOAT temp_float = ((ICS_PL_FLOAT)GET_Pl_WhlTqMaxEstimdLimAct());
                bus_cpy = (ICS_PL_U16_ICS_PL_FLOAT)(temp_float);
            }
            else
            {
                /* Automatically limit to DST.COD_UPPER_LIMIT */
                bus_cpy = 2900U;
            }
        }
        else
        {
            /* Automatically limit to DST.COD_LOWER_LIMIT */
            bus_cpy = 0U;
        }
    }
    else
    {
        /* SRC is not within the valid COD-range => cancel processing */
        tmp_return_value = ICS_PL_FALSE;
    }
    if(tmp_return_value == ICS_PL_TRUE)
    {
        /* Copy temporary-dst-container to DST */
        if(WRITE_SIGNAL_DATA_API(EDU1_outputShaftTorqueLimMax, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
        {
            tmp_return_value = ICS_PL_FALSE;
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EDU1_outputShaftTorqueLimMin
/*lint  -efile(451,ipl_hook_tx_prim_mcr.h) */
#include <ipl_hook_tx_prim_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EDU1_outputShaftTorqueLimMin) */
ICS_PL_RETURN_TYPE PL_Cvt_EDU1_outputShaftTorqueLimMin(void)
{
    /* Conversion for TX-Bus-Signal 'EDU1_outputShaftTorqueLimMin' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U16 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: Pl_WhlTqMinEstimdLimAct(intc_sigcv_tx_prim) */
    /*     Category, Type, Interface: NUM, ICS_PL_FLOAT, VAR */
    /*     Desc: Minimum available torque at wheels considering limitation of electrical machine. */
    /*     Harmonized Physical Range: [-4096...4095.875] [PD_Nm] */
    /*     Original Physical Range: [-4096...4095.875] [Nm] */
    /*     Variable-Name: Pl_WhlTqMinEstimdLimAct */
    
    /* Destination-Signal Description: */
    /*     Name: EDU1_outputShaftTorqueLimMin(intc_sigcv_tx_prim) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_U16, 13 bits, API */
    /*     Desc: Torque Limit in the EDU's reverse direction" */
    /*     State(s): [0x0...    ] */
    /*     Coded Range: [0x0...0xB54] */
    /*     Harmonized Physical Range: [0...2900] [Nm] */
    /*     Original Physical Range: [0...2900] [Nm] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_prim_Mapping_EDU1_outputShaftTorqueLimMin */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Init temporary-dst-container */
    bus_cpy = 0U;
    /* Range-Check. Potential violation of SRC.COD_LOWER_LIMIT and SRC.COD_UPPER_LIMIT */
    if((GET_Pl_WhlTqMinEstimdLimAct() <= 4095.875F) && (GET_Pl_WhlTqMinEstimdLimAct() >= -4096.0F))
    {
        /* Limitation Handling. Potential violation of DST.COD_LOWER_LIMIT */
        if(GET_Pl_WhlTqMinEstimdLimAct() >= 0.0F)
        {
            /* Limitation Handling. Potential violation of DST.COD_UPPER_LIMIT */
            if(GET_Pl_WhlTqMinEstimdLimAct() <= 2900.0F)
            {
                ICS_PL_FLOAT temp_float = ((ICS_PL_FLOAT)GET_Pl_WhlTqMinEstimdLimAct());
                bus_cpy = (ICS_PL_U16_ICS_PL_FLOAT)(temp_float);
            }
            else
            {
                /* Automatically limit to DST.COD_UPPER_LIMIT */
                bus_cpy = 2900U;
            }
        }
        else
        {
            /* Automatically limit to DST.COD_LOWER_LIMIT */
            bus_cpy = 0U;
        }
    }
    else
    {
        /* SRC is not within the valid COD-range => cancel processing */
        tmp_return_value = ICS_PL_FALSE;
    }
    if(tmp_return_value == ICS_PL_TRUE)
    {
        /* Copy temporary-dst-container to DST */
        if(WRITE_SIGNAL_DATA_API(EDU1_outputShaftTorqueLimMin, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
        {
            tmp_return_value = ICS_PL_FALSE;
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EDU1_outputShaftTorqueValid
/*lint  -efile(451,ipl_hook_tx_prim_mcr.h) */
#include <ipl_hook_tx_prim_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EDU1_outputShaftTorqueValid) */
ICS_PL_RETURN_TYPE PL_Cvt_EDU1_outputShaftTorqueValid(void)
{
    /* Conversion for TX-Bus-Signal 'EDU1_outputShaftTorqueValid' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_FLAG bus_cpy;
    
    
    /* Destination-Signal Description: */
    /*     Name: EDU1_outputShaftTorqueValid(intc_sigcv_tx_prim) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_FLAG, 1 bits, API */
    /*     Desc: Output Shaft torque valid" */
    /*     State(s): [0x0...    ] */
    /*     Coded Range: [0x0...0x1] */
    /*     Harmonized Physical Range: [0...1] [NoUnit] */
    /*     Original Physical Range: [0...1] [NoUnit] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_prim_Mapping_EDU1_outputShaftTorqueValid */
    /*     Processing: STUB */
    /*     Stub-Value: Dst-Signal.USER_VALUE */
    /*     Processing-Value-User-Value: 0x1 */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Stub DST to USER_VALUE */
    bus_cpy = ICS_PL_TRUE;
    /* Copy temporary-dst-container to DST */
    if(WRITE_SIGNAL_DATA_API(EDU1_outputShaftTorqueValid, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EDU1_rotorPosition
/*lint  -efile(451,ipl_hook_tx_prim_mcr.h) */
#include <ipl_hook_tx_prim_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EDU1_rotorPosition) */
ICS_PL_RETURN_TYPE PL_Cvt_EDU1_rotorPosition(void)
{
    /* Conversion for TX-Bus-Signal 'EDU1_rotorPosition' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U16 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: f32AngRotorEstim(intc_sigcv_tx_prim) */
    /*     Category, Type, Interface: NUM, ICS_PL_FLOAT, VAR */
    /*     Desc: Observer estimated rotor angle */
    /*     Harmonized Physical Range: [0...360] [deg] */
    /*     Original Physical Range: [0...6.283185482025] [rad] */
    /*     Variable-Name: f32AngRotorEstim */
    
    /* Destination-Signal Description: */
    /*     Name: EDU1_rotorPosition(intc_sigcv_tx_prim) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_U16, 12 bits, API */
    /*     Desc: Rotation Angle of the Rotor" */
    /*     State(s): [0x0...    ] */
    /*     Coded Range: [0x0...0xFFB] */
    /*     Harmonized Physical Range: [0...360] [deg] */
    /*     Original Physical Range: [0...360] [deg] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_prim_Mapping_EDU1_rotorPosition */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Init temporary-dst-container */
    bus_cpy = 0U;
    /* Range-Check. Potential violation of SRC.COD_LOWER_LIMIT and SRC.COD_UPPER_LIMIT */
    //if((GET_f32AngRotorEstim() <= 6.283185482025F) && (GET_f32AngRotorEstim() >= 0.0F))
    {
        ICS_PL_FLOAT temp_float = 0; // ((ICS_PL_FLOAT)GET_f32AngRotorEstim() * (ICS_PL_FLOAT) 651.1028540703714384868832229769);
        bus_cpy = (ICS_PL_U16_ICS_PL_FLOAT)(temp_float);
    }
    //else
    {
        /* SRC is not within the valid COD-range => cancel processing */
        tmp_return_value = ICS_PL_FALSE;
    }
    if(tmp_return_value == ICS_PL_TRUE)
    {
        /* Copy temporary-dst-container to DST */
        if(WRITE_SIGNAL_DATA_API(EDU1_rotorPosition, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
        {
            tmp_return_value = ICS_PL_FALSE;
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EDU1_rotorPositionValid
/*lint  -efile(451,ipl_hook_tx_prim_mcr.h) */
#include <ipl_hook_tx_prim_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EDU1_rotorPositionValid) */
ICS_PL_RETURN_TYPE PL_Cvt_EDU1_rotorPositionValid(void)
{
    /* Conversion for TX-Bus-Signal 'EDU1_rotorPositionValid' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_FLAG bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: Pl_LvStPosnRotorVld(intc_sigcv_tx_prim) */
    /*     Category, Type, Interface: TEXT, ICS_PL_FLAG, VAR */
    /*     Desc: Valid flag for rotor position based on rotor position sensor diagnosis */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     FALSE [0x0; 0x0] */
    /*     TRUE [0x1; 0x1] */
    /*     Variable-Name: Pl_LvStPosnRotorVld */
    
    /* Destination-Signal Description: */
    /*     Name: EDU1_rotorPositionValid(intc_sigcv_tx_prim) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_FLAG, 1 bits, API */
    /*     Desc: Rotation Angle of the Rotor valid" */
    /*     State(s): [0x0...    ] */
    /*     Coded Range: [0x0...0x1] */
    /*     Harmonized Physical Range: [0...1] [NoUnit] */
    /*     Original Physical Range: [0...1] [NoUnit] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_prim_Mapping_EDU1_rotorPositionValid */
    /*     Processing: FORCE */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Force PL to perform an 1:1 mapping  */
    if(GET_Pl_LvStPosnRotorVld() == ICS_PL_TRUE)
    {
        bus_cpy = ICS_PL_TRUE;
    }
    else
    {
        bus_cpy = ICS_PL_FALSE;
    }
    /* Copy temporary-dst-container to DST */
    if(WRITE_SIGNAL_DATA_API(EDU1_rotorPositionValid, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EDU1_rotorSpeed
/*lint  -efile(451,ipl_hook_tx_prim_mcr.h) */
#include <ipl_hook_tx_prim_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EDU1_rotorSpeed) */
ICS_PL_RETURN_TYPE PL_Cvt_EDU1_rotorSpeed(void)
{
    /* Conversion for TX-Bus-Signal 'EDU1_rotorSpeed' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_S16 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: f32NRotorLpfSlow(intc_sigcv_tx_prim) */
    /*     Category, Type, Interface: NUM, ICS_PL_FLOAT, VAR */
    /*     Desc: Actual rpm from electric machine */
    /*     Harmonized Physical Range: [-32768...32767] [rpm] */
    /*     Original Physical Range: [-32768...32767] [rpm] */
    /*     Variable-Name: f32NRotorLpfSlow */
    
    /* Destination-Signal Description: */
    /*     Name: EDU1_rotorSpeed(intc_sigcv_tx_prim) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_S16, 14 bits, API */
    /*     Desc: Rotor speed, not scaled by gearbox ratio" */
    /*     State(s): [0x0...    ] */
    /*     Coded Range: [0xE03E...0x1FC2] */
    /*     Harmonized Physical Range: [-10000...10000] [rpm] */
    /*     Original Physical Range: [-10000...10000] [rpm] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_prim_Mapping_EDU1_rotorSpeed */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Init temporary-dst-container */
    bus_cpy = 0;
    /* Range-Check. Potential violation of SRC.COD_LOWER_LIMIT and SRC.COD_UPPER_LIMIT */
    if((GET_f32NRotorLpfSlow() <= 32767.0F) && (GET_f32NRotorLpfSlow() >= -32768.0F))
    {
        /* Limitation Handling. Potential violation of DST.COD_LOWER_LIMIT */
        if(GET_f32NRotorLpfSlow() >= -10000.0F)
        {
            /* Limitation Handling. Potential violation of DST.COD_UPPER_LIMIT */
            if(GET_f32NRotorLpfSlow() <= 10000.0F)
            {
                ICS_PL_FLOAT temp_float = ((ICS_PL_FLOAT)GET_f32NRotorLpfSlow() * (ICS_PL_FLOAT) 0.813);
                bus_cpy = (ICS_PL_S16_ICS_PL_FLOAT)(temp_float);
            }
            else
            {
                /* Automatically limit to DST.COD_UPPER_LIMIT */
                bus_cpy = 8130;
            }
        }
        else
        {
            /* Automatically limit to DST.COD_LOWER_LIMIT */
            bus_cpy = ((ICS_PL_S16)-8130);
        }
    }
    else
    {
        /* SRC is not within the valid COD-range => cancel processing */
        tmp_return_value = ICS_PL_FALSE;
    }
    if(tmp_return_value == ICS_PL_TRUE)
    {
        /* Copy temporary-dst-container to DST */
        if(WRITE_SIGNAL_DATA_API(EDU1_rotorSpeed, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
        {
            tmp_return_value = ICS_PL_FALSE;
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EDU1_rotorSpeedValid
/*lint  -efile(451,ipl_hook_tx_prim_mcr.h) */
#include <ipl_hook_tx_prim_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EDU1_rotorSpeedValid) */
ICS_PL_RETURN_TYPE PL_Cvt_EDU1_rotorSpeedValid(void)
{
    /* Conversion for TX-Bus-Signal 'EDU1_rotorSpeedValid' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_FLAG bus_cpy;
    
    
    /* Destination-Signal Description: */
    /*     Name: EDU1_rotorSpeedValid(intc_sigcv_tx_prim) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_FLAG, 1 bits, API */
    /*     Desc: Rotor speed valid" */
    /*     State(s): [0x0...    ] */
    /*     Coded Range: [0x0...0x1] */
    /*     Harmonized Physical Range: [0...1] [NoUnit] */
    /*     Original Physical Range: [0...1] [NoUnit] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_prim_Mapping_EDU1_rotorSpeedValid */
    /*     Processing: STUB */
    /*     Stub-Value: Dst-Signal.USER_VALUE */
    /*     Processing-Value-User-Value: 0x1 */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Stub DST to USER_VALUE */
    bus_cpy = ICS_PL_TRUE;
    /* Copy temporary-dst-container to DST */
    if(WRITE_SIGNAL_DATA_API(EDU1_rotorSpeedValid, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EDU1_rotorTemp
/*lint  -efile(451,ipl_hook_tx_prim_mcr.h) */
#include <ipl_hook_tx_prim_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EDU1_rotorTemp) */
ICS_PL_RETURN_TYPE PL_Cvt_EDU1_rotorTemp(void)
{
    /* Conversion for TX-Bus-Signal 'EDU1_rotorTemp' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U8 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: Pl_EmRotorTEstimd(intc_sigcv_tx_prim) */
    /*     Category, Type, Interface: NUM, ICS_PL_FLOAT, VAR */
    /* Desc: Permanent Magnet Synchronous Machine rotor temperature value for protection of electric */
    /* machine */
    /*     Harmonized Physical Range: [-273.15...238.8421875] [degC] */
    /*     Original Physical Range: [0...511.9921875] [K] */
    /*     Variable-Name: Pl_EmRotorTEstimd */
    
    /* Destination-Signal Description: */
    /*     Name: EDU1_rotorTemp(intc_sigcv_tx_prim) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_U8, 8 bits, API */
    /*     Desc: Estimated rotor temperature" */
    /*     State(s): [0x0...    ] */
    /*     Coded Range: [0x0...0xFE] */
    /*     Harmonized Physical Range: [-40...214] [degC] */
    /*     Original Physical Range: [-40...214] [degC] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_prim_Mapping_EDU1_rotorTemp */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Init temporary-dst-container */
    bus_cpy = 0U;
    /* Range-Check. Potential violation of SRC.COD_LOWER_LIMIT and SRC.COD_UPPER_LIMIT */
    if((GET_Pl_EmRotorTEstimd() <= 511.9921875F) && (GET_Pl_EmRotorTEstimd() >= 0.0F))
    {
        /* Limitation Handling. Potential violation of DST.COD_LOWER_LIMIT */
        if(GET_Pl_EmRotorTEstimd() >= 233.15F)
        {
            /* Limitation Handling. Potential violation of DST.COD_UPPER_LIMIT */
            if(GET_Pl_EmRotorTEstimd() <= 487.15F)
            {
                ICS_PL_FLOAT temp_float = ((ICS_PL_FLOAT)GET_Pl_EmRotorTEstimd() + (ICS_PL_FLOAT)-233.15);
                bus_cpy = (ICS_PL_U8_ICS_PL_FLOAT)(temp_float);
            }
            else
            {
                /* Automatically limit to DST.COD_UPPER_LIMIT */
                bus_cpy = 254U;
            }
        }
        else
        {
            /* Automatically limit to DST.COD_LOWER_LIMIT */
            bus_cpy = 0U;
        }
    }
    else
    {
        /* SRC is not within the valid COD-range => cancel processing */
        tmp_return_value = ICS_PL_FALSE;
    }
    if(tmp_return_value == ICS_PL_TRUE)
    {
        /* Copy temporary-dst-container to DST */
        if(WRITE_SIGNAL_DATA_API(EDU1_rotorTemp, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
        {
            tmp_return_value = ICS_PL_FALSE;
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EDU1_statorTemp
/*lint  -efile(451,ipl_hook_tx_prim_mcr.h) */
#include <ipl_hook_tx_prim_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EDU1_statorTemp) */
ICS_PL_RETURN_TYPE PL_Cvt_EDU1_statorTemp(void)
{
    /* Conversion for TX-Bus-Signal 'EDU1_statorTemp' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U8 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: Pl_EmStatorTHotSpotEstimd(intc_sigcv_tx_prim) */
    /*     Category, Type, Interface: NUM, ICS_PL_FLOAT, VAR */
    /*     Desc: Filtered estimated stator temperature */
    /*     Harmonized Physical Range: [-273.15...238.8421875] [degC] */
    /*     Original Physical Range: [0...511.9921875] [K] */
    /*     Variable-Name: Pl_EmStatorTHotSpotEstimd */
    
    /* Destination-Signal Description: */
    /*     Name: EDU1_statorTemp(intc_sigcv_tx_prim) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_U8, 8 bits, API */
    /*     Desc: Max of all the measured stator temperatures" */
    /*     State(s): [0x0...    ] */
    /*     Coded Range: [0x0...0xFE] */
    /*     Harmonized Physical Range: [-40...214] [degC] */
    /*     Original Physical Range: [-40...214] [degC] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_prim_Mapping_EDU1_statorTemp */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Init temporary-dst-container */
    bus_cpy = 0U;
    /* Range-Check. Potential violation of SRC.COD_LOWER_LIMIT and SRC.COD_UPPER_LIMIT */
    if((GET_Pl_EmStatorTHotSpotEstimd() <= 511.9921875F) && (GET_Pl_EmStatorTHotSpotEstimd() >= 0.0F))
    {
        /* Limitation Handling. Potential violation of DST.COD_LOWER_LIMIT */
        if(GET_Pl_EmStatorTHotSpotEstimd() >= 233.15F)
        {
            /* Limitation Handling. Potential violation of DST.COD_UPPER_LIMIT */
            if(GET_Pl_EmStatorTHotSpotEstimd() <= 487.15F)
            {
                ICS_PL_FLOAT temp_float = ((ICS_PL_FLOAT)GET_Pl_EmStatorTHotSpotEstimd() + (ICS_PL_FLOAT)-233.15);
                bus_cpy = (ICS_PL_U8_ICS_PL_FLOAT)(temp_float);
            }
            else
            {
                /* Automatically limit to DST.COD_UPPER_LIMIT */
                bus_cpy = 254U;
            }
        }
        else
        {
            /* Automatically limit to DST.COD_LOWER_LIMIT */
            bus_cpy = 0U;
        }
    }
    else
    {
        /* SRC is not within the valid COD-range => cancel processing */
        tmp_return_value = ICS_PL_FALSE;
    }
    if(tmp_return_value == ICS_PL_TRUE)
    {
        /* Copy temporary-dst-container to DST */
        if(WRITE_SIGNAL_DATA_API(EDU1_statorTemp, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
        {
            tmp_return_value = ICS_PL_FALSE;
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduPrim_EDU1_heatPower
/*lint  -efile(451,ipl_hook_tx_prim_mcr.h) */
#include <ipl_hook_tx_prim_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduPrim_EDU1_heatPower) */
ICS_PL_RETURN_TYPE PL_Cvt_EduPrim_EDU1_heatPower(void)
{
    /* Conversion for TX-Bus-Signal 'EduPrim_EDU1_heatPower' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U16 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: Pl_PwrLossElInvt(intc_sigcv_tx_prim) */
    /*     Category, Type, Interface: NUM, ICS_PL_FLOAT, VAR */
    /*     Desc: Electrical power losses from inverter */
    /*     Harmonized Physical Range: [-67108864...67108863.96875] [PD_W] */
    /*     Original Physical Range: [-67108864...67108863.96875] [W] */
    /*     Variable-Name: Pl_PwrLossElInvt */
    
    /* Destination-Signal Description: */
    /*     Name: EduPrim_EDU1_heatPower(intc_sigcv_tx_prim) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_U16, 9 bits, API */
    /*     Desc: Power converted to heat" */
    /*     State(s): [0x0...    ] */
    /*     Coded Range: [0x0...0x1FE] */
    /*     Harmonized Physical Range: [0...5100] [W] */
    /*     Original Physical Range: [0...5100] [W] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_prim_Mapping_EDU1_heatPower */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Init temporary-dst-container */
    bus_cpy = 0U;
    /* Range-Check. Potential violation of SRC.COD_LOWER_LIMIT and SRC.COD_UPPER_LIMIT */
    if((GET_Pl_PwrLossElInvt() <= 67108863.96875F) && (GET_Pl_PwrLossElInvt() >= -67108864.0F))
    {
        /* Limitation Handling. Potential violation of DST.COD_LOWER_LIMIT */
        if(GET_Pl_PwrLossElInvt() >= 0.0F)
        {
            /* Limitation Handling. Potential violation of DST.COD_UPPER_LIMIT */
            if(GET_Pl_PwrLossElInvt() <= 5100.0F)
            {
                ICS_PL_FLOAT temp_float = ((ICS_PL_FLOAT)GET_Pl_PwrLossElInvt() * (ICS_PL_FLOAT) 0.1);
                bus_cpy = (ICS_PL_U16_ICS_PL_FLOAT)(temp_float);
            }
            else
            {
                /* Automatically limit to DST.COD_UPPER_LIMIT */
                bus_cpy = 510U;
            }
        }
        else
        {
            /* Automatically limit to DST.COD_LOWER_LIMIT */
            bus_cpy = 0U;
        }
    }
    else
    {
        /* SRC is not within the valid COD-range => cancel processing */
        tmp_return_value = ICS_PL_FALSE;
    }
    if(tmp_return_value == ICS_PL_TRUE)
    {
        /* Copy temporary-dst-container to DST */
        if(WRITE_SIGNAL_DATA_API(EduPrim_EDU1_heatPower, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
        {
            tmp_return_value = ICS_PL_FALSE;
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduPrim_EDU1_heatPowerLimit
/*lint  -efile(451,ipl_hook_tx_prim_mcr.h) */
#include <ipl_hook_tx_prim_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduPrim_EDU1_heatPowerLimit) */
ICS_PL_RETURN_TYPE PL_Cvt_EduPrim_EDU1_heatPowerLimit(void)
{
    /* Conversion for TX-Bus-Signal 'EduPrim_EDU1_heatPowerLimit' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U16 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: Pl_PwrLossInvtMaxEstim(intc_sigcv_tx_prim) */
    /*     Category, Type, Interface: NUM, ICS_PL_FLOAT, VAR */
    /*     Desc: Maximum estimated electric power losses on IGBT and diode for inverter */
    /*     Harmonized Physical Range: [-67108864...67108863.96875] [PD_W] */
    /*     Original Physical Range: [-67108864...67108863.96875] [W] */
    /*     Variable-Name: Pl_PwrLossInvtMaxEstim */
    
    /* Destination-Signal Description: */
    /*     Name: EduPrim_EDU1_heatPowerLimit(intc_sigcv_tx_prim) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_U16, 9 bits, API */
    /*     Desc: Maximum power to use for heat" */
    /*     State(s): [0x0...    ] */
    /*     Coded Range: [0x0...0x1FE] */
    /*     Harmonized Physical Range: [0...5100] [W] */
    /*     Original Physical Range: [0...5100] [W] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_prim_Mapping_EDU1_heatPowerLimit */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Init temporary-dst-container */
    bus_cpy = 0U;
    /* Range-Check. Potential violation of SRC.COD_LOWER_LIMIT and SRC.COD_UPPER_LIMIT */
    if((GET_Pl_PwrLossInvtMaxEstim() <= 67108863.96875F) && (GET_Pl_PwrLossInvtMaxEstim() >= -67108864.0F))
    {
        /* Limitation Handling. Potential violation of DST.COD_LOWER_LIMIT */
        if(GET_Pl_PwrLossInvtMaxEstim() >= 0.0F)
        {
            /* Limitation Handling. Potential violation of DST.COD_UPPER_LIMIT */
            if(GET_Pl_PwrLossInvtMaxEstim() <= 5100.0F)
            {
                ICS_PL_FLOAT temp_float = ((ICS_PL_FLOAT)GET_Pl_PwrLossInvtMaxEstim() * (ICS_PL_FLOAT) 0.1);
                bus_cpy = (ICS_PL_U16_ICS_PL_FLOAT)(temp_float);
            }
            else
            {
                /* Automatically limit to DST.COD_UPPER_LIMIT */
                bus_cpy = 510U;
            }
        }
        else
        {
            /* Automatically limit to DST.COD_LOWER_LIMIT */
            bus_cpy = 0U;
        }
    }
    else
    {
        /* SRC is not within the valid COD-range => cancel processing */
        tmp_return_value = ICS_PL_FALSE;
    }
    if(tmp_return_value == ICS_PL_TRUE)
    {
        /* Copy temporary-dst-container to DST */
        if(WRITE_SIGNAL_DATA_API(EduPrim_EDU1_heatPowerLimit, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
        {
            tmp_return_value = ICS_PL_FALSE;
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduPrim_EDU_a000_to_a031
/*lint  -efile(451,ipl_hook_tx_prim_mcr.h) */
#include <ipl_hook_tx_prim_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduPrim_EDU_a000_to_a031) */
ICS_PL_RETURN_TYPE PL_Cvt_EduPrim_EDU_a000_to_a031(void)
{
    /* Conversion for TX-Bus-Signal 'EduPrim_EDU_a000_to_a031' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U32 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: u32AlertStatusBits_low(intc_sigcv_tx_prim) */
    /*     Category, Type, Interface: NUM, ICS_PL_U32, VAR */
    /*     State(s): [0x0...0xFFFFFFFF] */
    /*     Coded Range: [0x00...0xFFFFFFFF] */
    /*     Harmonized Physical Range: [0...4294967295] [NoUnit] */
    /*     Original Physical Range: [0...4294967295] [NoUnit] */
    /*     Variable-Name: u32AlertStatusBits_low */
    
    /* Destination-Signal Description: */
    /*     Name: EduPrim_EDU_a000_to_a031(intc_sigcv_tx_prim) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_U32, 32 bits, API */
    /*     State(s): [0x0...0xFFFFFFFF] */
    /*     Coded Range: [0x00...0xFFFFFFFF] */
    /*     Harmonized Physical Range: [0...4294967295] [NoUnit] */
    /*     Original Physical Range: [0...4294967295] [NoUnit] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_prim_Mapping00065 */
    /*     Processing: BYPASS */
    /*     Bypass-Callout: ByPass_EduPrim_EDU_a000_to_a031 */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Init temporary-dst-container */
    bus_cpy = 0U;
    
    /* Bypass PL */
    if(ByPass_EduPrim_EDU_a000_to_a031(GET_u32AlertStatusBits_low(), &bus_cpy) == ICS_PL_TRUE)
    {
        /* Copy temporary-dst-container to DST */
        if(WRITE_SIGNAL_DATA_API(EduPrim_EDU_a000_to_a031, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
        {
            tmp_return_value = ICS_PL_FALSE;
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduPrim_EDU_a032_to_a059
/*lint  -efile(451,ipl_hook_tx_prim_mcr.h) */
#include <ipl_hook_tx_prim_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduPrim_EDU_a032_to_a059) */
ICS_PL_RETURN_TYPE PL_Cvt_EduPrim_EDU_a032_to_a059(void)
{
    /* Conversion for TX-Bus-Signal 'EduPrim_EDU_a032_to_a059' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U32 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: u32AlertStatusBits_high(intc_sigcv_tx_prim) */
    /*     Category, Type, Interface: NUM, ICS_PL_U32, VAR */
    /*     State(s): [0x0...0xFFFFFFFF] */
    /*     Coded Range: [0x00...0xFFFFFFFF] */
    /*     Harmonized Physical Range: [0...4294967295] [NoUnit] */
    /*     Original Physical Range: [0...4294967295] [NoUnit] */
    /*     Variable-Name: u32AlertStatusBits_high */
    
    /* Destination-Signal Description: */
    /*     Name: EduPrim_EDU_a032_to_a059(intc_sigcv_tx_prim) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_U32, 28 bits, API */
    /*     State(s): [0x0...0xFFFFFFFF] */
    /*     Coded Range: [0x00...0x0FFFFFFF] */
    /*     Harmonized Physical Range: [0...268435455] [NoUnit] */
    /*     Original Physical Range: [0...268435455] [NoUnit] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_prim_Mapping00066 */
    /*     Processing: BYPASS */
    /*     Bypass-Callout: ByPass_EduPrim_EDU_a032_to_a059 */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Init temporary-dst-container */
    bus_cpy = 0U;
    
    /* Bypass PL */
    if(ByPass_EduPrim_EDU_a032_to_a059(GET_u32AlertStatusBits_high(), &bus_cpy) == ICS_PL_TRUE)
    {
        /* Copy temporary-dst-container to DST */
        if(WRITE_SIGNAL_DATA_API(EduPrim_EDU_a032_to_a059, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
        {
            tmp_return_value = ICS_PL_FALSE;
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduPrim_EDU_alertStatusMult_0
/*lint  -efile(451,ipl_hook_tx_prim_mcr.h) */
#include <ipl_hook_tx_prim_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduPrim_EDU_alertStatusMult_0) */
ICS_PL_RETURN_TYPE PL_Cvt_EduPrim_EDU_alertStatusMult_0(void)
{
    /* Conversion for TX-Bus-Signal 'EduPrim_EDU_alertStatusMult_0' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U8 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: u8AlertStatusMult(intc_sigcv_tx_prim) */
    /*     Category, Type, Interface: NUM, ICS_PL_U8, VAR */
    /*     Desc: Alert Status Multiplexing */
    /*     State(s): [0x0...0xFF] */
    /*     Coded Range: [0x00...0xF] */
    /*     Harmonized Physical Range: [0...15] [NoUnit] */
    /*     Original Physical Range: [0...15] [NoUnit] */
    /*     Variable-Name: u8AlertStatusMult */
    
    /* Destination-Signal Description: */
    /*     Name: EduPrim_EDU_alertStatusMult_0(intc_sigcv_tx_prim) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_U8, 4 bits, API */
    /*     State(s): [0x0...0x0] */
    /*     Coded Range: [0x00...0xF] */
    /*     Harmonized Physical Range: [0...15] [NoUnit] */
    /*     Original Physical Range: [0...15] [NoUnit] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_prim_Mapping00067 */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Init temporary-dst-container */
    bus_cpy = 0U;
    /* Range-Check. Potential violation of SRC.COD_UPPER_LIMIT */
    if(GET_u8AlertStatusMult() <= 15U)
    {
        /* Conversion of 'u8AlertStatusMult' to 'EduPrim_EDU_alertStatusMult_0' */
        /*lint -save -e734 */
        bus_cpy = GET_u8AlertStatusMult();
        /*lint -restore */
    }
    else
    {
        /* SRC is not within the valid COD-range => cancel processing */
        tmp_return_value = ICS_PL_FALSE;
    }
    if(tmp_return_value == ICS_PL_TRUE)
    {
        /* Copy temporary-dst-container to DST */
        if(WRITE_SIGNAL_DATA_API(EduPrim_EDU_alertStatusMult_0, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
        {
            tmp_return_value = ICS_PL_FALSE;
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduPrim_EDU_voltageDc
/*lint  -efile(451,ipl_hook_tx_prim_mcr.h) */
#include <ipl_hook_tx_prim_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduPrim_EDU_voltageDc) */
ICS_PL_RETURN_TYPE PL_Cvt_EduPrim_EDU_voltageDc(void)
{
    /* Conversion for TX-Bus-Signal 'EduPrim_EDU_voltageDc' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U16 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: Pl_HvDcUMeasd(intc_sigcv_tx_prim) */
    /*     Category, Type, Interface: NUM, ICS_PL_S16, VAR */
    /*     Desc: Second low pass filtered of primary voltage sensor */
    /*     Coded Range: [0x8000...0x7FFF] */
    /*     Harmonized Physical Range: [-2048...2047.9375] [PD_V] */
    /*     Original Physical Range: [-2048...2047.9375] [V] */
    /*     Variable-Name: Pl_HvDcUMeasd */
    
    /* Destination-Signal Description: */
    /*     Name: EduPrim_EDU_voltageDc(intc_sigcv_tx_prim) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_U16, 9 bits, API */
    /*     Desc: High voltage bus measurement" */
    /*     State(s): [0x0...    ] */
    /*     Coded Range: [0x0...0x1FF] */
    /*     Harmonized Physical Range: [0...511] [V] */
    /*     Original Physical Range: [0...511] [V] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_prim_Mapping_EDU1_voltageDc */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Init temporary-dst-container */
    bus_cpy = 0U;
    /* Limitation Handling. Potential violation of DST.COD_LOWER_LIMIT */
    if(GET_Pl_HvDcUMeasd() >= 0)
    {
        /* Limitation Handling. Potential violation of DST.COD_UPPER_LIMIT */
        if(GET_Pl_HvDcUMeasd() <= 8168)
        {
            /* Conversion of 'Pl_HvDcUMeasd' to 'EduPrim_EDU_voltageDc' */
            /*lint -save -e734 */
            /*lint -save -e571 */
            bus_cpy = ((((ICS_PL_U16)GET_Pl_HvDcUMeasd()) + 8U) / 16U);
            /*lint -restore */
            /*lint -restore */
        }
        else
        {
            /* Automatically limit to DST.COD_UPPER_LIMIT */
            bus_cpy = 511U;
        }
    }
    else
    {
        /* Automatically limit to DST.COD_LOWER_LIMIT */
        bus_cpy = 0U;
    }
    /* Copy temporary-dst-container to DST */
    if(WRITE_SIGNAL_DATA_API(EduPrim_EDU_voltageDc, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
