/****************************************************************************
 * COPYRIGHT VITESCO TECHNOLOGIES GROUP AG (EXCLUSIVE RIGHTS) 
 * Confidential
 * 
 * The reproduction, transmission or use of this document or its
 * contents is not permitted without express written authority.
 * Offenders will be liable for damages. All rights, including rights
 * created by patent grant or registration of a utility model or design,
 * are reserved.
 *---------------------------------------------------------------------------
 * 
 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 * !!! This file is generated by Signal Mapper (SIMA) Code-Generator !!!
 * !!! Do NOT modify this file manually                            !!!
 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 * 
 * Purpose:    PL Hook Implementation
 * 
 * Processor:  independent
 * Tool chain: 
 *    CG-Version:        6.2.0
 *    Schema-Version:    1.18.0
 *    Generation-Date:   03.09.2024  15:13:28  
 *    Generated by user: uiv10169
 * Filename:   $Workfile$
 * Revision:   $Revision: 1.2 $
 * Author:     $Author: Ling Jiaming (uiv10169) (uiv10169) $
 * Date:       $Date: 2024/09/05 08:20:29CEST $
 * Changes:    $Log: ipl_hook_rx_sec.c  $
 * Changes:    Revision 1.2 2024/09/05 08:20:29CEST Ling Jiaming (uiv10169) (uiv10169) 
 * Changes:    add new interface Pl_VehSysDwnTiMins
 * 
****************************************************************************/
/*lint -esym(750,IPL_HOOK_RX_SEC_C) */
#define IPL_HOOK_RX_SEC_C
#include <intc_sigcv_mc1_im.h>


#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduSec_EMU_EDU_antiJerkEnable
/*lint  -efile(451,ipl_hook_rx_sec_mcr.h) */
#include <ipl_hook_rx_sec_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduSec_EMU_EDU_antiJerkEnable) */
ICS_PL_RETURN_TYPE PL_Cvt_EduSec_EMU_EDU_antiJerkEnable(void)
{
    /* Conversion for RX-Bus-Signal 'EduSec_EMU_EDU_antiJerkEnable' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_FLAG bus_cpy;
    ICS_PL_FLAG sys_cpy0 = ICS_PL_FALSE;
    
    
    /* Source-Signal Description: */
    /*     Name: EduSec_EMU_EDU_antiJerkEnable(intc_sigcv_rx_sec) */
    /*     Category, Type, length, Interface: TEXT, ICS_PL_FLAG, 1 bits, API */
    /*     Desc:  */
    /*     State(s): [0x0...    ] */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     DISABLE [0x0; 0x0] */
    /*     ENABLE [0x1; 0x1] */
    
    /* Destination-Signal Description: */
    /*     Name: Pl_AntiJerkEna_Sec(intc_sigcv_rx_sec) */
    /*     Category, Type, Interface: TEXT, ICS_PL_FLAG, VAR */
    /*     Desc: External anti-jerk active */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     FALSE [0x0; 0x0] */
    /*     TRUE  [0x1; 0x1] */
    /*     Variable-Name: Pl_AntiJerkEna_Sec */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_rx_sec_Mapping00081 */
    /*     Processing: UNCONDITIONAL */
    /*     Text Mapping */
    /*     SRC -> DST */
    /*     DISABLE[0x0] -> FALSE[0x0] */
    /*     ENABLE[0x1] -> TRUE [0x1] */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    bus_cpy = ICS_PL_FALSE;
    if(READ_SIGNAL_DATA_API(EduSec_EMU_EDU_antiJerkEnable, &bus_cpy) == READ_SIGNAL_DATA_API_SUCCESS)
    {
        
        if(bus_cpy == ICS_PL_FALSE)
        {
            /* Map SRC-Value 'DISABLE' to DST-Value 'FALSE' */
            sys_cpy0 = ICS_PL_FALSE;
        }
        else
        {
            /* Map SRC-Value 'ENABLE' to DST-Value 'TRUE ' */
            sys_cpy0 = ICS_PL_TRUE;
        }
        /* Copy temporary-dst-container to DST */
        SET_Pl_AntiJerkEna_Sec(sys_cpy0);
    }
    else
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduSec_EMU_EDU_antiJerkGain
/*lint  -efile(451,ipl_hook_rx_sec_mcr.h) */
#include <ipl_hook_rx_sec_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduSec_EMU_EDU_antiJerkGain) */
ICS_PL_RETURN_TYPE PL_Cvt_EduSec_EMU_EDU_antiJerkGain(void)
{
    /* Conversion for RX-Bus-Signal 'EduSec_EMU_EDU_antiJerkGain' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U16 bus_cpy;
    ICS_PL_FLOAT sys_cpy0 = 0.0F;
    
    
    /* Source-Signal Description: */
    /*     Name: EduSec_EMU_EDU_antiJerkGain(intc_sigcv_rx_sec) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_U16, 10 bits, API */
    /*     Desc:  */
    /*     State(s): [0x0...    ] */
    /*     Coded Range: [0x0...0x3FF] */
    /*     Harmonized Physical Range: [0.15...10.38] [NoUnit] */
    /*     Original Physical Range: [0.15...10.38] [NoUnit] */
    
    /* Destination-Signal Description: */
    /*     Name: Pl_AntiJerkGain_Sec(intc_sigcv_rx_sec) */
    /*     Category, Type, Interface: NUM, ICS_PL_FLOAT, VAR */
    /*     Desc: External amplification factor for dynamic electrical machine torque path of anti-jerk */
    /*     Harmonized Physical Range: [-524288...524272] [PD_NmMuls] */
    /*     Original Physical Range: [-524288...524272] [NmMuls] */
    /*     Variable-Name: Pl_AntiJerkGain_Sec */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_rx_sec_Mapping00084 */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    bus_cpy = 0U;
    if(READ_SIGNAL_DATA_API(EduSec_EMU_EDU_antiJerkGain, &bus_cpy) == READ_SIGNAL_DATA_API_SUCCESS)
    {
        
        /* Range-Check. Potential violation of SRC.COD_UPPER_LIMIT */
        if(bus_cpy <= 1023U)
        {
            sys_cpy0 = ((ICS_PL_FLOAT)bus_cpy * ((ICS_PL_FLOAT)0.01)) + ((ICS_PL_FLOAT)0.15);

        }
        else
        {
            /* SRC is not within the valid COD-range => cancel processing */
            tmp_return_value = ICS_PL_FALSE;
        }
        if(tmp_return_value == ICS_PL_TRUE)
        {
            /* Copy temporary-dst-container to DST */
            SET_Pl_AntiJerkGain_Sec(sys_cpy0);
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduSec_EMU_EDU_antiJerkMaxTorq
/*lint  -efile(451,ipl_hook_rx_sec_mcr.h) */
#include <ipl_hook_rx_sec_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduSec_EMU_EDU_antiJerkMaxTorq) */
ICS_PL_RETURN_TYPE PL_Cvt_EduSec_EMU_EDU_antiJerkMaxTorq(void)
{
    /* Conversion for RX-Bus-Signal 'EduSec_EMU_EDU_antiJerkMaxTorq' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U8 bus_cpy;
    ICS_PL_FLOAT sys_cpy0 = 0.0F;
    
    
    /* Source-Signal Description: */
    /*     Name: EduSec_EMU_EDU_antiJerkMaxTorq(intc_sigcv_rx_sec) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_U8, 7 bits, API */
    /*     Desc:  */
    /*     State(s): [0x0...    ] */
    /*     Coded Range: [0x0...0x40] */
    /*     Harmonized Physical Range: [0...40] [Nm] */
    /*     Original Physical Range: [0...40] [Nm] */
    
    /* Destination-Signal Description: */
    /*     Name: Pl_AntiJerkTqLimMax_Sec(intc_sigcv_rx_sec) */
    /*     Category, Type, Interface: NUM, ICS_PL_FLOAT, VAR */
    /*     Desc: Requested maximum electric machine torque limit for anti-jerk */
    /*     Harmonized Physical Range: [-1024...99] [PD_Nm] */
    /*     Original Physical Range: [-1024...99] [Nm] */
    /*     Variable-Name: Pl_AntiJerkTqLimMax_Sec */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_rx_sec_Mapping00087 */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    bus_cpy = 0U;
    if(READ_SIGNAL_DATA_API(EduSec_EMU_EDU_antiJerkMaxTorq, &bus_cpy) == READ_SIGNAL_DATA_API_SUCCESS)
    {
        
        /* Range-Check. Potential violation of SRC.COD_UPPER_LIMIT */
        if(bus_cpy <= 64U)
        {
            sys_cpy0 = ((ICS_PL_FLOAT)bus_cpy * (ICS_PL_FLOAT)0.625);

        }
        else
        {
            /* SRC is not within the valid COD-range => cancel processing */
            tmp_return_value = ICS_PL_FALSE;
        }
        if(tmp_return_value == ICS_PL_TRUE)
        {
            /* Copy temporary-dst-container to DST */
            SET_Pl_AntiJerkTqLimMax_Sec(sys_cpy0);
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduSec_EMU_EDU_antiJerkMinTorq
/*lint  -efile(451,ipl_hook_rx_sec_mcr.h) */
#include <ipl_hook_rx_sec_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduSec_EMU_EDU_antiJerkMinTorq) */
ICS_PL_RETURN_TYPE PL_Cvt_EduSec_EMU_EDU_antiJerkMinTorq(void)
{
    /* Conversion for RX-Bus-Signal 'EduSec_EMU_EDU_antiJerkMinTorq' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U8 bus_cpy;
    ICS_PL_FLOAT sys_cpy0 = 0.0F;
    
    
    /* Source-Signal Description: */
    /*     Name: EduSec_EMU_EDU_antiJerkMinTorq(intc_sigcv_rx_sec) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_U8, 7 bits, API */
    /*     Desc:  */
    /*     State(s): [0x0...    ] */
    /*     Coded Range: [0x0...0x40] */
    /*     Harmonized Physical Range: [0...40] [Nm] */
    /*     Original Physical Range: [0...40] [Nm] */
    
    /* Destination-Signal Description: */
    /*     Name: Pl_AntiJerkTqLimMin_Sec(intc_sigcv_rx_sec) */
    /*     Category, Type, Interface: NUM, ICS_PL_FLOAT, VAR */
    /*     Desc: Requested minimum electric machine torque limit for anti-jerk */
    /*     Harmonized Physical Range: [-1024...1023.96875] [PD_Nm] */
    /*     Original Physical Range: [-1024...1023.96875] [Nm] */
    /*     Variable-Name: Pl_AntiJerkTqLimMin_Sec */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_rx_sec_Mapping00089 */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    bus_cpy = 0U;
    if(READ_SIGNAL_DATA_API(EduSec_EMU_EDU_antiJerkMinTorq, &bus_cpy) == READ_SIGNAL_DATA_API_SUCCESS)
    {
        
        /* Range-Check. Potential violation of SRC.COD_UPPER_LIMIT */
        if(bus_cpy <= 64U)
        {
            sys_cpy0 = ((ICS_PL_FLOAT)bus_cpy * (ICS_PL_FLOAT)0.625);

        }
        else
        {
            /* SRC is not within the valid COD-range => cancel processing */
            tmp_return_value = ICS_PL_FALSE;
        }
        if(tmp_return_value == ICS_PL_TRUE)
        {
            /* Copy temporary-dst-container to DST */
            SET_Pl_AntiJerkTqLimMin_Sec(sys_cpy0);
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduSec_EMU_EDU_antiJerkSpeedThres
/*lint  -efile(451,ipl_hook_rx_sec_mcr.h) */
#include <ipl_hook_rx_sec_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduSec_EMU_EDU_antiJerkSpeedThres) */
ICS_PL_RETURN_TYPE PL_Cvt_EduSec_EMU_EDU_antiJerkSpeedThres(void)
{
    /* Conversion for RX-Bus-Signal 'EduSec_EMU_EDU_antiJerkSpeedThres' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U16 bus_cpy;
    ICS_PL_FLOAT sys_cpy0 = 0.0F;
    
    
    /* Source-Signal Description: */
    /*     Name: EduSec_EMU_EDU_antiJerkSpeedThres(intc_sigcv_rx_sec) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_U16, 10 bits, API */
    /*     Desc:  */
    /*     State(s): [0x0...    ] */
    /*     Coded Range: [0x0...0x3FF] */
    /*     Harmonized Physical Range: [30...1029.47] [rpm] */
    /*     Original Physical Range: [30...1029.47] [rpm] */
    
    /* Destination-Signal Description: */
    /*     Name: Pl_AntiJerkEnaSpdThd_Sec(intc_sigcv_rx_sec) */
    /*     Category, Type, Interface: NUM, ICS_PL_FLOAT, VAR */
    /*     Desc: External electrical machine speed oscillation threshold for anti-jerk */
    /*     Harmonized Physical Range: [-512...511.984375] [PD_Pers] */
    /*     Original Physical Range: [-512...511.984375] [Pers] */
    /*     Variable-Name: Pl_AntiJerkEnaSpdThd_Sec */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_rx_sec_Mapping00092 */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    bus_cpy = 0U;
    if(READ_SIGNAL_DATA_API(EduSec_EMU_EDU_antiJerkSpeedThres, &bus_cpy) == READ_SIGNAL_DATA_API_SUCCESS)
    {
        
        /* Range-Check. Potential violation of SRC.COD_UPPER_LIMIT */
        if(bus_cpy <= 1023U)
        {
            /* Limitation Handling. Potential violation of DST.COD_UPPER_LIMIT */
            if(bus_cpy <= 493U)
            {
                sys_cpy0 = ((ICS_PL_FLOAT)bus_cpy * ((ICS_PL_FLOAT)0.97699902248289345063538611926)) + ((ICS_PL_FLOAT)30);

            }
            else
            {
                /* Automatically limit to DST.COD_UPPER_LIMIT */
                sys_cpy0 = 511.984375F;
            }
        }
        else
        {
            /* SRC is not within the valid COD-range => cancel processing */
            tmp_return_value = ICS_PL_FALSE;
        }
        if(tmp_return_value == ICS_PL_TRUE)
        {
            /* Copy temporary-dst-container to DST */
            SET_Pl_AntiJerkEnaSpdThd_Sec(sys_cpy0);
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduSec_EMU_EDU_clutchReq
/*lint  -efile(451,ipl_hook_rx_sec_mcr.h) */
#include <ipl_hook_rx_sec_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduSec_EMU_EDU_clutchReq) */
ICS_PL_RETURN_TYPE PL_Cvt_EduSec_EMU_EDU_clutchReq(void)
{
    /* Conversion for RX-Bus-Signal 'EduSec_EMU_EDU_clutchReq' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U8 bus_cpy;
    ICS_PL_U8 sys_cpy0 = 0U;
    
    
    /* Source-Signal Description: */
    /*     Name: EduSec_EMU_EDU_clutchReq(intc_sigcv_rx_sec) */
    /*     Category, Type, length, Interface: TEXT, ICS_PL_U8, 3 bits, API */
    /*     Desc: EMU clutch request" */
    /*     State(s): [0x0...    ] */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     FAST_DISENGAGE [0x4; 0x4] */
    /*     FAST_ENGAGE [0x3; 0x3] */
    /*     COMFORT_ENGAGE [0x2; 0x2] */
    /*     COMFORT_DISENGAGE [0x1; 0x1] */
    /*     NO_REQUEST [0x0; 0x0] */
    
    /* Destination-Signal Description: */
    /*     Name: Pl_VehCluAxleSet_Sec(intc_sigcv_rx_sec) */
    /*     Category, Type, Interface: TEXT, ICS_PL_U8, VAR */
    /*     Desc: Gearbox clutch engage and disengage mode request */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     NONE_REQ [0x0; 0x0] */
    /*     CFT_DISCNCT [0x1; 0x1] */
    /*     CFT_CNCT [0x2; 0x2] */
    /*     FAST_CNCT [0x3; 0x3] */
    /*     FAST_DISCNCT [0x4; 0x4] */
    /*     Variable-Name: Pl_VehCluAxleSet_Sec */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_rx_sec_Mapping00095 */
    /*     Processing: UNCONDITIONAL */
    /*     Text Mapping */
    /*     SRC -> DST */
    /*     NO_REQUEST[0x0] -> NONE_REQ[0x0] */
    /*     COMFORT_DISENGAGE[0x1] -> CFT_DISCNCT[0x1] */
    /*     COMFORT_ENGAGE[0x2] -> CFT_CNCT[0x2] */
    /*     FAST_ENGAGE[0x3] -> FAST_CNCT[0x3] */
    /*     FAST_DISENGAGE[0x4] -> FAST_DISCNCT[0x4] */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    bus_cpy = 0U;
    if(READ_SIGNAL_DATA_API(EduSec_EMU_EDU_clutchReq, &bus_cpy) == READ_SIGNAL_DATA_API_SUCCESS)
    {
        
        if(bus_cpy == 0U)
        {
            /* Map SRC-Value 'NO_REQUEST' to DST-Value 'NONE_REQ' */
            sys_cpy0 = 0U;
        }
        else if(bus_cpy == 1U)
        {
            /* Map SRC-Value 'COMFORT_DISENGAGE' to DST-Value 'CFT_DISCNCT' */
            sys_cpy0 = 1U;
        }
        else if(bus_cpy == 2U)
        {
            /* Map SRC-Value 'COMFORT_ENGAGE' to DST-Value 'CFT_CNCT' */
            sys_cpy0 = 2U;
        }
        else if(bus_cpy == 3U)
        {
            /* Map SRC-Value 'FAST_ENGAGE' to DST-Value 'FAST_CNCT' */
            sys_cpy0 = 3U;
        }
        else if(bus_cpy == 4U)
        {
            /* Map SRC-Value 'FAST_DISENGAGE' to DST-Value 'FAST_DISCNCT' */
            sys_cpy0 = 4U;
        }
        else
        {
            /* SRC is not within the valid COD-range => cancel processing */
            tmp_return_value = ICS_PL_FALSE;
        }
        if(tmp_return_value == ICS_PL_TRUE)
        {
            /* Copy temporary-dst-container to DST */
            SET_Pl_VehCluAxleSet_Sec(sys_cpy0);
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduSec_EMU_EDU_hvOnRequest
/*lint  -efile(451,ipl_hook_rx_sec_mcr.h) */
#include <ipl_hook_rx_sec_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduSec_EMU_EDU_hvOnRequest) */
ICS_PL_RETURN_TYPE PL_Cvt_EduSec_EMU_EDU_hvOnRequest(void)
{
    /* Conversion for RX-Bus-Signal 'EduSec_EMU_EDU_hvOnRequest' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_FLAG bus_cpy;
    ICS_PL_FLAG sys_cpy0 = ICS_PL_FALSE;
    
    
    /* Source-Signal Description: */
    /*     Name: EduSec_EMU_EDU_hvOnRequest(intc_sigcv_rx_sec) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_FLAG, 1 bits, API */
    /*     Desc: HV is requested, to be used to turn on internal PS" */
    /*     State(s): [0x0...0x0] */
    /*     Coded Range: [0x0...0x1] */
    /*     Harmonized Physical Range: [0...1] [unit1] */
    /*     Original Physical Range: [0...1] [unit1] */
    
    /* Destination-Signal Description: */
    /*     Name: Pl_LvUHvsReqExtEna_Sec(intc_sigcv_rx_sec) */
    /*     Category, Type, Interface: TEXT, ICS_PL_FLAG, VAR */
    /*     Desc: External request to enable high voltage */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     FALSE [0x0; 0x0] */
    /*     TRUE [0x1; 0x1] */
    /*     Variable-Name: Pl_LvUHvsReqExtEna_Sec */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_rx_sec_Mapping00098 */
    /*     Processing: FORCE */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    bus_cpy = ICS_PL_FALSE;
    if(READ_SIGNAL_DATA_API(EduSec_EMU_EDU_hvOnRequest, &bus_cpy) == READ_SIGNAL_DATA_API_SUCCESS)
    {
        
        /* Force PL to perform an 1:1 mapping  */
        if(bus_cpy == ICS_PL_TRUE)
        {
            sys_cpy0 = ICS_PL_TRUE;
        }
        else
        {
            sys_cpy0 = ICS_PL_FALSE;
        }
        /* Copy temporary-dst-container to DST */
        SET_Pl_LvUHvsReqExtEna_Sec(sys_cpy0);
    }
    else
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduSec_EMU_EDU_iLimitMax
/*lint  -efile(451,ipl_hook_rx_sec_mcr.h) */
#include <ipl_hook_rx_sec_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduSec_EMU_EDU_iLimitMax) */
ICS_PL_RETURN_TYPE PL_Cvt_EduSec_EMU_EDU_iLimitMax(void)
{
    /* Conversion for RX-Bus-Signal 'EduSec_EMU_EDU_iLimitMax' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U16 bus_cpy;
    ICS_PL_U16 sys_cpy0 = 0U;
    
    
    /* Source-Signal Description: */
    /*     Name: EduSec_EMU_EDU_iLimitMax(intc_sigcv_rx_sec) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_U16, 9 bits, API */
    /*     Desc: Current limit for torque generated in the EDU's forward direction" */
    /*     Coded Range: [0x0...0x1FF] */
    /*     Harmonized Physical Range: [0...511] [A] */
    /*     Original Physical Range: [0...511] [A] */
    
    /* Destination-Signal Description: */
    /*     Name: Pl_VehHvDcILimMax_Sec(intc_sigcv_rx_sec) */
    /*     Category, Type, Interface: NUM, ICS_PL_U16, VAR */
    /*     Desc: Signal representing predicted maximum DC link current coming from the communication */
    /*     Coded Range: [0x0...0xFFFF] */
    /*     Harmonized Physical Range: [0...65535] [PD_NoUnit] */
    /*     Original Physical Range: [0...65535] [NoUnit] */
    /*     Variable-Name: Pl_VehHvDcILimMax_Sec */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_rx_sec_Mapping00058 */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    bus_cpy = 0U;
    if(READ_SIGNAL_DATA_API(EduSec_EMU_EDU_iLimitMax, &bus_cpy) == READ_SIGNAL_DATA_API_SUCCESS)
    {
        
        /* Range-Check. Potential violation of SRC.COD_UPPER_LIMIT */
        if(bus_cpy <= 511U)
        {
            /* Conversion of 'EduSec_EMU_EDU_iLimitMax' to 'Pl_VehHvDcILimMax_Sec' */
            /*lint -save -e734 */
            sys_cpy0 = bus_cpy;
            /*lint -restore */
        }
        else
        {
            /* SRC is not within the valid COD-range => cancel processing */
            tmp_return_value = ICS_PL_FALSE;
        }
        if(tmp_return_value == ICS_PL_TRUE)
        {
            /* Copy temporary-dst-container to DST */
            SET_Pl_VehHvDcILimMax_Sec(sys_cpy0);
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduSec_EMU_EDU_iLimitMin
/*lint  -efile(451,ipl_hook_rx_sec_mcr.h) */
#include <ipl_hook_rx_sec_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduSec_EMU_EDU_iLimitMin) */
ICS_PL_RETURN_TYPE PL_Cvt_EduSec_EMU_EDU_iLimitMin(void)
{
    /* Conversion for RX-Bus-Signal 'EduSec_EMU_EDU_iLimitMin' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U16 bus_cpy;
    ICS_PL_U16 sys_cpy0 = 0U;
    
    
    /* Source-Signal Description: */
    /*     Name: EduSec_EMU_EDU_iLimitMin(intc_sigcv_rx_sec) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_U16, 9 bits, API */
    /*     Desc: Current limit for torque generated in the EDU's reverse direction" */
    /*     Coded Range: [0x0...0x1FF] */
    /*     Harmonized Physical Range: [0...511] [A] */
    /*     Original Physical Range: [0...511] [A] */
    
    /* Destination-Signal Description: */
    /*     Name: Pl_VehHvDcILimMin_Sec(intc_sigcv_rx_sec) */
    /*     Category, Type, Interface: NUM, ICS_PL_U16, VAR */
    /*     Desc: Signal representing predicted minimum DC link current coming from the communication */
    /*     Coded Range: [0x0...0xFFFF] */
    /*     Harmonized Physical Range: [0...65535] [PD_NoUnit] */
    /*     Original Physical Range: [0...65535] [NoUnit] */
    /*     Variable-Name: Pl_VehHvDcILimMin_Sec */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_rx_sec_Mapping00061 */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    bus_cpy = 0U;
    if(READ_SIGNAL_DATA_API(EduSec_EMU_EDU_iLimitMin, &bus_cpy) == READ_SIGNAL_DATA_API_SUCCESS)
    {
        
        /* Range-Check. Potential violation of SRC.COD_UPPER_LIMIT */
        if(bus_cpy <= 511U)
        {
            /* Conversion of 'EduSec_EMU_EDU_iLimitMin' to 'Pl_VehHvDcILimMin_Sec' */
            /*lint -save -e734 */
            sys_cpy0 = bus_cpy;
            /*lint -restore */
        }
        else
        {
            /* SRC is not within the valid COD-range => cancel processing */
            tmp_return_value = ICS_PL_FALSE;
        }
        if(tmp_return_value == ICS_PL_TRUE)
        {
            /* Copy temporary-dst-container to DST */
            SET_Pl_VehHvDcILimMin_Sec(sys_cpy0);
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduSec_EMU_EDU_inverterStateReq
/*lint  -efile(451,ipl_hook_rx_sec_mcr.h) */
#include <ipl_hook_rx_sec_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduSec_EMU_EDU_inverterStateReq) */
ICS_PL_RETURN_TYPE PL_Cvt_EduSec_EMU_EDU_inverterStateReq(void)
{
    /* Conversion for RX-Bus-Signal 'EduSec_EMU_EDU_inverterStateReq' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U8 bus_cpy;
    ICS_PL_U8 sys_cpy0 = 0U;
    
    
    /* Source-Signal Description: */
    /*     Name: EduSec_EMU_EDU_inverterStateReq(intc_sigcv_rx_sec) */
    /*     Category, Type, length, Interface: TEXT, ICS_PL_U8, 3 bits, API */
    /*     Desc: EMU control state request" */
    /*     State(s): [0x0...    ] */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     ACTIVE_SHORT_CIRCUIT [0x6; 0x6] */
    /*     ACTIVE_DISCHARGE [0x5; 0x5] */
    /*     SPEED_CONTROL [0x4; 0x4] */
    /*     CALIBRATE [0x3; 0x3] */
    /*     NOT_USED [0x2; 0x2] */
    /*     TORQUE_CONTROL [0x1; 0x1] */
    /*     PASSIVE [0x0; 0x0] */
    
    /* Destination-Signal Description: */
    /*     Name: Pl_VehPeModeReq_Sec(intc_sigcv_rx_sec) */
    /*     Category, Type, Interface: NUM, ICS_PL_U8, VAR */
    /*     Desc: Electrical machine state requested by main external function */
    /*     Coded Range: [0x0...0xFF] */
    /*     Harmonized Physical Range: [0...255] [PD_NoUnit] */
    /*     Original Physical Range: [0...255] [NoUnit] */
    /*     Variable-Name: Pl_VehPeModeReq_Sec */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_rx_sec_Mapping00049 */
    /*     Processing: FORCE */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    bus_cpy = 0U;
    if(READ_SIGNAL_DATA_API(EduSec_EMU_EDU_inverterStateReq, &bus_cpy) == READ_SIGNAL_DATA_API_SUCCESS)
    {
        
        /* Force PL to perform an 1:1 mapping  */
        sys_cpy0 = (ICS_PL_U8)bus_cpy;
        /* Copy temporary-dst-container to DST */
        SET_Pl_VehPeModeReq_Sec(sys_cpy0);
    }
    else
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduSec_EMU_EDU_outputShaftTorqueReq
/*lint  -efile(451,ipl_hook_rx_sec_mcr.h) */
#include <ipl_hook_rx_sec_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduSec_EMU_EDU_outputShaftTorqueReq) */
ICS_PL_RETURN_TYPE PL_Cvt_EduSec_EMU_EDU_outputShaftTorqueReq(void)
{
    /* Conversion for RX-Bus-Signal 'EduSec_EMU_EDU_outputShaftTorqueReq' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_S16 bus_cpy;
    ICS_PL_FLOAT sys_cpy0 = 0.0F;
    
    
    /* Source-Signal Description: */
    /*     Name: EduSec_EMU_EDU_outputShaftTorqueReq(intc_sigcv_rx_sec) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_S16, 13 bits, API */
    /*     Desc: EMU control torque request" */
    /*     State(s): [0x0...    ] */
    /*     Coded Range: [0xF4AC...0xB54] */
    /*     Harmonized Physical Range: [-2900...2900] [Nm_Sl] */
    /*     Original Physical Range: [-2900...2900] [Nm] */
    
    /* Destination-Signal Description: */
    /*     Name: Pl_VehWhlTqTgt_Sec(intc_sigcv_rx_sec) */
    /*     Category, Type, Interface: NUM, ICS_PL_FLOAT, VAR */
    /*     Desc: Electrical machine torque requested by main external function */
    /*     Harmonized Physical Range: [-4096...4095.875] [PD_Nm] */
    /*     Original Physical Range: [-4096...4095.875] [Nm] */
    /*     Variable-Name: Pl_VehWhlTqTgt_Sec */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_rx_sec_Mapping00052 */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    bus_cpy = 0;
    if(READ_SIGNAL_DATA_API(EduSec_EMU_EDU_outputShaftTorqueReq, &bus_cpy) == READ_SIGNAL_DATA_API_SUCCESS)
    {
        
        /* Range-Check. Potential violation of SRC.COD_LOWER_LIMIT and SRC.COD_UPPER_LIMIT */
        if((bus_cpy <= 2900) && (bus_cpy >= -2900))
        {
            sys_cpy0 = ((ICS_PL_FLOAT)bus_cpy);

        }
        else
        {
            /* SRC is not within the valid COD-range => cancel processing */
            tmp_return_value = ICS_PL_FALSE;
        }
        if(tmp_return_value == ICS_PL_TRUE)
        {
            /* Copy temporary-dst-container to DST */
            SET_Pl_VehWhlTqTgt_Sec(sys_cpy0);
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduSec_EMU_EDU_outputShaftTrqMax
/*lint  -efile(451,ipl_hook_rx_sec_mcr.h) */
#include <ipl_hook_rx_sec_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduSec_EMU_EDU_outputShaftTrqMax) */
ICS_PL_RETURN_TYPE PL_Cvt_EduSec_EMU_EDU_outputShaftTrqMax(void)
{
    /* Conversion for RX-Bus-Signal 'EduSec_EMU_EDU_outputShaftTrqMax' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U16 bus_cpy;
    ICS_PL_FLOAT sys_cpy0 = 0.0F;
    
    
    /* Source-Signal Description: */
    /*     Name: EduSec_EMU_EDU_outputShaftTrqMax(intc_sigcv_rx_sec) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_U16, 13 bits, API */
    /*     Desc: Wheel Speed Max limit in Speed Control Mode" */
    /*     State(s): [0x0...    ] */
    /*     Coded Range: [0x0...0xB54] */
    /*     Harmonized Physical Range: [0...2900] [Nm] */
    /*     Original Physical Range: [0...2900] [Nm] */
    
    /* Destination-Signal Description: */
    /*     Name: Pl_VehWhlTqMaxLim_Sec(intc_sigcv_rx_sec) */
    /*     Category, Type, Interface: NUM, ICS_PL_FLOAT, VAR */
    /*     Desc: Maximum electrical machine torque requested by main external function */
    /*     Harmonized Physical Range: [-4096...4095.875] [PD_Nm] */
    /*     Original Physical Range: [-4096...4095.875] [Nm] */
    /*     Variable-Name: Pl_VehWhlTqMaxLim_Sec */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_rx_sec_Mapping00039 */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    bus_cpy = 0U;
    if(READ_SIGNAL_DATA_API(EduSec_EMU_EDU_outputShaftTrqMax, &bus_cpy) == READ_SIGNAL_DATA_API_SUCCESS)
    {
        
        /* Range-Check. Potential violation of SRC.COD_UPPER_LIMIT */
        if(bus_cpy <= 2900U)
        {
            sys_cpy0 = ((ICS_PL_FLOAT)bus_cpy);

        }
        else
        {
            /* SRC is not within the valid COD-range => cancel processing */
            tmp_return_value = ICS_PL_FALSE;
        }
        if(tmp_return_value == ICS_PL_TRUE)
        {
            /* Copy temporary-dst-container to DST */
            SET_Pl_VehWhlTqMaxLim_Sec(sys_cpy0);
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduSec_EMU_EDU_outputShaftTrqMin
/*lint  -efile(451,ipl_hook_rx_sec_mcr.h) */
#include <ipl_hook_rx_sec_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduSec_EMU_EDU_outputShaftTrqMin) */
ICS_PL_RETURN_TYPE PL_Cvt_EduSec_EMU_EDU_outputShaftTrqMin(void)
{
    /* Conversion for RX-Bus-Signal 'EduSec_EMU_EDU_outputShaftTrqMin' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U16 bus_cpy;
    ICS_PL_FLOAT sys_cpy0 = 0.0F;
    
    
    /* Source-Signal Description: */
    /*     Name: EduSec_EMU_EDU_outputShaftTrqMin(intc_sigcv_rx_sec) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_U16, 13 bits, API */
    /*     Desc: Wheel Speed Min limit in Speed Control Mode" */
    /*     State(s): [0x0...    ] */
    /*     Coded Range: [0x0...0xB54] */
    /*     Harmonized Physical Range: [0...2900] [Nm] */
    /*     Original Physical Range: [0...2900] [Nm] */
    
    /* Destination-Signal Description: */
    /*     Name: Pl_VehWhlTqMinLim_Sec(intc_sigcv_rx_sec) */
    /*     Category, Type, Interface: NUM, ICS_PL_FLOAT, VAR */
    /*     Desc: Minimum electrical machine torque requested by main external function */
    /*     Harmonized Physical Range: [-4096...4095.875] [PD_Nm] */
    /*     Original Physical Range: [-4096...4095.875] [Nm] */
    /*     Variable-Name: Pl_VehWhlTqMinLim_Sec */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_rx_sec_Mapping00042 */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    bus_cpy = 0U;
    if(READ_SIGNAL_DATA_API(EduSec_EMU_EDU_outputShaftTrqMin, &bus_cpy) == READ_SIGNAL_DATA_API_SUCCESS)
    {
        
        /* Range-Check. Potential violation of SRC.COD_UPPER_LIMIT */
        if(bus_cpy <= 2900U)
        {
            sys_cpy0 = ((ICS_PL_FLOAT)bus_cpy);

        }
        else
        {
            /* SRC is not within the valid COD-range => cancel processing */
            tmp_return_value = ICS_PL_FALSE;
        }
        if(tmp_return_value == ICS_PL_TRUE)
        {
            /* Copy temporary-dst-container to DST */
            SET_Pl_VehWhlTqMinLim_Sec(sys_cpy0);
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduSec_EMU_EDU_pwtCoolantFlow
/*lint  -efile(451,ipl_hook_rx_sec_mcr.h) */
#include <ipl_hook_rx_sec_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduSec_EMU_EDU_pwtCoolantFlow) */
ICS_PL_RETURN_TYPE PL_Cvt_EduSec_EMU_EDU_pwtCoolantFlow(void)
{
    /* Conversion for RX-Bus-Signal 'EduSec_EMU_EDU_pwtCoolantFlow' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U8 bus_cpy;
    ICS_PL_FLOAT sys_cpy0 = 0.0F;
    
    
    /* Source-Signal Description: */
    /*     Name: EduSec_EMU_EDU_pwtCoolantFlow(intc_sigcv_rx_sec) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_U8, 6 bits, API */
    /*     Desc: Powertrain coolant loop flow value North" */
    /*     State(s): [0x0...    ] */
    /*     Coded Range: [0x0...0x3C] */
    /*     Harmonized Physical Range: [0...15] [lpm] */
    /*     Original Physical Range: [0...15] [lpm] */
    
    /* Destination-Signal Description: */
    /*     Name: Pl_VehCooltInvInVolFlow_Sec(intc_sigcv_rx_sec) */
    /*     Category, Type, Interface: NUM, ICS_PL_FLOAT, VAR */
    /*     Desc: Coolant volume flow */
    /*     Harmonized Physical Range: [0...15] [PD_lpm] */
    /*     Original Physical Range: [0...15] [lpm] */
    /*     Variable-Name: Pl_VehCooltInvInVolFlow_Sec */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_rx_sec_Mapping00045 */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    bus_cpy = 0U;
    if(READ_SIGNAL_DATA_API(EduSec_EMU_EDU_pwtCoolantFlow, &bus_cpy) == READ_SIGNAL_DATA_API_SUCCESS)
    {
        
        /* Range-Check. Potential violation of SRC.COD_UPPER_LIMIT */
        if(bus_cpy <= 60U)
        {
            sys_cpy0 = ((ICS_PL_FLOAT)bus_cpy * (ICS_PL_FLOAT)0.25);

        }
        else
        {
            /* SRC is not within the valid COD-range => cancel processing */
            tmp_return_value = ICS_PL_FALSE;
        }
        if(tmp_return_value == ICS_PL_TRUE)
        {
            /* Copy temporary-dst-container to DST */
            SET_Pl_VehCooltInvInVolFlow_Sec(sys_cpy0);
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduSec_EMU_EDU_pwtCoolantFlowValid
/*lint  -efile(451,ipl_hook_rx_sec_mcr.h) */
#include <ipl_hook_rx_sec_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduSec_EMU_EDU_pwtCoolantFlowValid) */
ICS_PL_RETURN_TYPE PL_Cvt_EduSec_EMU_EDU_pwtCoolantFlowValid(void)
{
    /* Conversion for RX-Bus-Signal 'EduSec_EMU_EDU_pwtCoolantFlowValid' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_FLAG bus_cpy;
    ICS_PL_FLAG sys_cpy0 = ICS_PL_FALSE;
    
    
    /* Source-Signal Description: */
    /*     Name: EduSec_EMU_EDU_pwtCoolantFlowValid(intc_sigcv_rx_sec) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_FLAG, 1 bits, API */
    /*     Desc: Powertrain coolant loop flow valid North" */
    /*     State(s): [0x0...    ] */
    /*     Coded Range: [0x0...0x1] */
    /*     Harmonized Physical Range: [0...1] [NoUnit] */
    /*     Original Physical Range: [0...1] [NoUnit] */
    
    /* Destination-Signal Description: */
    /*     Name: Pl_VehCooltInvInVolFlowVld_Sec(intc_sigcv_rx_sec) */
    /*     Category, Type, Interface: NUM, ICS_PL_FLAG, VAR */
    /*     Desc: Powertrain coolant loop flow valid North" */
    /*     Coded Range: [0x0...0x1] */
    /*     Harmonized Physical Range: [0...1] [NoUnit] */
    /*     Original Physical Range: [0...1] [NoUnit] */
    /*     Variable-Name: Pl_VehCooltInvInVolFlowVld_Sec */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_rx_sec_Mapping00070 */
    /*     Processing: FORCE */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    bus_cpy = ICS_PL_FALSE;
    if(READ_SIGNAL_DATA_API(EduSec_EMU_EDU_pwtCoolantFlowValid, &bus_cpy) == READ_SIGNAL_DATA_API_SUCCESS)
    {
        
        /* Force PL to perform an 1:1 mapping  */
        if(bus_cpy == ICS_PL_TRUE)
        {
            sys_cpy0 = ICS_PL_TRUE;
        }
        else
        {
            sys_cpy0 = ICS_PL_FALSE;
        }
        /* Copy temporary-dst-container to DST */
        SET_Pl_VehCooltInvInVolFlowVld_Sec(sys_cpy0);
    }
    else
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduSec_EMU_EDU_systemDowntime
/*lint  -efile(451,ipl_hook_rx_sec_mcr.h) */
#include <ipl_hook_rx_sec_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduSec_EMU_EDU_systemDowntime) */
ICS_PL_RETURN_TYPE PL_Cvt_EduSec_EMU_EDU_systemDowntime(void)
{
    /* Conversion for RX-Bus-Signal 'EduSec_EMU_EDU_systemDowntime' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U16 bus_cpy;
    ICS_PL_U16 sys_cpy0 = 0U;
    
    
    /* Source-Signal Description: */
    /*     Name: EduSec_EMU_EDU_systemDowntime(intc_sigcv_rx_sec) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_U16, 11 bits, API */
    /*     Desc: Time duration how long the vehicle was in shutdown state" */
    /*     State(s): [0x0...    ] */
    /*     Coded Range: [0x0...0x7FF] */
    /*     Harmonized Physical Range: [0...2047] [Min] */
    /*     Original Physical Range: [0...2047] [Min] */
    
    /* Destination-Signal Description: */
    /*     Name: Pl_VehSysDwnTiMins_Sec(intc_sigcv_rx_sec) */
    /*     Category, Type, Interface: NUM, ICS_PL_U16, VAR */
    /*     Desc: Time duration how long the vehicle was in shutdown state */
    /*     Coded Range: [0x00...0x7FF] */
    /*     Harmonized Physical Range: [0...2047] [PD_min] */
    /*     Original Physical Range: [0...2047] [min] */
    /*     Variable-Name: Pl_VehSysDwnTiMins_Sec */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_rx_sec_Mapping00023 */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    bus_cpy = 0U;
    if(READ_SIGNAL_DATA_API(EduSec_EMU_EDU_systemDowntime, &bus_cpy) == READ_SIGNAL_DATA_API_SUCCESS)
    {
        
        /* Range-Check. Potential violation of SRC.COD_UPPER_LIMIT */
        if(bus_cpy <= 2047U)
        {
            /* Conversion of 'EduSec_EMU_EDU_systemDowntime' to 'Pl_VehSysDwnTiMins_Sec' */
            /*lint -save -e734 */
            sys_cpy0 = bus_cpy;
            /*lint -restore */
        }
        else
        {
            /* SRC is not within the valid COD-range => cancel processing */
            tmp_return_value = ICS_PL_FALSE;
        }
        if(tmp_return_value == ICS_PL_TRUE)
        {
            /* Copy temporary-dst-container to DST */
            SET_Pl_VehSysDwnTiMins_Sec(sys_cpy0);
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduSec_EMU_EDU_wheelRpmGbxSide
/*lint  -efile(451,ipl_hook_rx_sec_mcr.h) */
#include <ipl_hook_rx_sec_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduSec_EMU_EDU_wheelRpmGbxSide) */
ICS_PL_RETURN_TYPE PL_Cvt_EduSec_EMU_EDU_wheelRpmGbxSide(void)
{
    /* Conversion for RX-Bus-Signal 'EduSec_EMU_EDU_wheelRpmGbxSide' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_S16 bus_cpy;
    ICS_PL_FLOAT sys_cpy0 = 0.0F;
    
    
    /* Source-Signal Description: */
    /*     Name: EduSec_EMU_EDU_wheelRpmGbxSide(intc_sigcv_rx_sec) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_S16, 14 bits, API */
    /*     Desc: Speed of the gearbox-side/Q2 wheel in vehicle reference frame" */
    /*     State(s): [0x0...    ] */
    /*     Coded Range: [0xE000...0x1FC0] */
    /*     Harmonized Physical Range: [-2048...2032] [rpm] */
    /*     Original Physical Range: [-2048...2032] [rpm] */
    
    /* Destination-Signal Description: */
    /*     Name: Pl_VehWhlSpd2_Sec(intc_sigcv_rx_sec) */
    /*     Category, Type, Interface: NUM, ICS_PL_FLOAT, VAR */
    /*     Harmonized Physical Range: [-2048...2032] [PD_rpm] */
    /*     Original Physical Range: [-2048...2032] [rpm] */
    /*     Variable-Name: Pl_VehWhlSpd2_Sec */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_rx_sec_Mapping00101 */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    bus_cpy = 0;
    if(READ_SIGNAL_DATA_API(EduSec_EMU_EDU_wheelRpmGbxSide, &bus_cpy) == READ_SIGNAL_DATA_API_SUCCESS)
    {
        
        /* Range-Check. Potential violation of SRC.COD_LOWER_LIMIT and SRC.COD_UPPER_LIMIT */
        if((bus_cpy <= 8128) && (bus_cpy >= -8192))
        {
            sys_cpy0 = ((ICS_PL_FLOAT)bus_cpy * (ICS_PL_FLOAT)0.25);

        }
        else
        {
            /* SRC is not within the valid COD-range => cancel processing */
            tmp_return_value = ICS_PL_FALSE;
        }
        if(tmp_return_value == ICS_PL_TRUE)
        {
            /* Copy temporary-dst-container to DST */
            SET_Pl_VehWhlSpd2_Sec(sys_cpy0);
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduSec_EMU_EDU_wheelRpmMtrSide
/*lint  -efile(451,ipl_hook_rx_sec_mcr.h) */
#include <ipl_hook_rx_sec_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduSec_EMU_EDU_wheelRpmMtrSide) */
ICS_PL_RETURN_TYPE PL_Cvt_EduSec_EMU_EDU_wheelRpmMtrSide(void)
{
    /* Conversion for RX-Bus-Signal 'EduSec_EMU_EDU_wheelRpmMtrSide' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_S16 bus_cpy;
    ICS_PL_FLOAT sys_cpy0 = 0.0F;
    
    
    /* Source-Signal Description: */
    /*     Name: EduSec_EMU_EDU_wheelRpmMtrSide(intc_sigcv_rx_sec) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_S16, 14 bits, API */
    /*     Desc: Speed of the motor-side/Q1 wheel in vehicle reference frame" */
    /*     State(s): [0x0...    ] */
    /*     Coded Range: [0xE000...0x1FC0] */
    /*     Harmonized Physical Range: [-2048...2032] [rpm] */
    /*     Original Physical Range: [-2048...2032] [rpm] */
    
    /* Destination-Signal Description: */
    /*     Name: Pl_VehWhlSpd1_Sec(intc_sigcv_rx_sec) */
    /*     Category, Type, Interface: NUM, ICS_PL_FLOAT, VAR */
    /*     Harmonized Physical Range: [-2048...2032] [PD_rpm] */
    /*     Original Physical Range: [-2048...2032] [rpm] */
    /*     Variable-Name: Pl_VehWhlSpd1_Sec */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_rx_sec_Mapping00104 */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    bus_cpy = 0;
    if(READ_SIGNAL_DATA_API(EduSec_EMU_EDU_wheelRpmMtrSide, &bus_cpy) == READ_SIGNAL_DATA_API_SUCCESS)
    {
        
        /* Range-Check. Potential violation of SRC.COD_LOWER_LIMIT and SRC.COD_UPPER_LIMIT */
        if((bus_cpy <= 8128) && (bus_cpy >= -8192))
        {
            sys_cpy0 = ((ICS_PL_FLOAT)bus_cpy * (ICS_PL_FLOAT)0.25);

        }
        else
        {
            /* SRC is not within the valid COD-range => cancel processing */
            tmp_return_value = ICS_PL_FALSE;
        }
        if(tmp_return_value == ICS_PL_TRUE)
        {
            /* Copy temporary-dst-container to DST */
            SET_Pl_VehWhlSpd1_Sec(sys_cpy0);
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduSec_EMU_EDU_wheelRpmValidGbxSide
/*lint  -efile(451,ipl_hook_rx_sec_mcr.h) */
#include <ipl_hook_rx_sec_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduSec_EMU_EDU_wheelRpmValidGbxSide) */
ICS_PL_RETURN_TYPE PL_Cvt_EduSec_EMU_EDU_wheelRpmValidGbxSide(void)
{
    /* Conversion for RX-Bus-Signal 'EduSec_EMU_EDU_wheelRpmValidGbxSide' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_FLAG bus_cpy;
    ICS_PL_FLAG sys_cpy0 = ICS_PL_FALSE;
    
    
    /* Source-Signal Description: */
    /*     Name: EduSec_EMU_EDU_wheelRpmValidGbxSide(intc_sigcv_rx_sec) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_FLAG, 1 bits, API */
    /*     Desc: Validity flag for the gearbox-side/Q2 wheel speed" */
    /*     State(s): [0x0...    ] */
    /*     Coded Range: [0x0...0x1] */
    /*     Harmonized Physical Range: [0...1] [NoUnit] */
    /*     Original Physical Range: [0...1] [NoUnit] */
    
    /* Destination-Signal Description: */
    /*     Name: Pl_VehWhlSpdVld2_Sec(intc_sigcv_rx_sec) */
    /*     Category, Type, Interface: TEXT, ICS_PL_FLAG, VAR */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     FALSE [0x0; 0x0] */
    /*     TRUE [0x1; 0x1] */
    /*     Variable-Name: Pl_VehWhlSpdVld2_Sec */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_rx_sec_Mapping00107 */
    /*     Processing: FORCE */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    bus_cpy = ICS_PL_FALSE;
    if(READ_SIGNAL_DATA_API(EduSec_EMU_EDU_wheelRpmValidGbxSide, &bus_cpy) == READ_SIGNAL_DATA_API_SUCCESS)
    {
        
        /* Force PL to perform an 1:1 mapping  */
        if(bus_cpy == ICS_PL_TRUE)
        {
            sys_cpy0 = ICS_PL_TRUE;
        }
        else
        {
            sys_cpy0 = ICS_PL_FALSE;
        }
        /* Copy temporary-dst-container to DST */
        SET_Pl_VehWhlSpdVld2_Sec(sys_cpy0);
    }
    else
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduSec_EMU_EDU_wheelRpmValidMtrSide
/*lint  -efile(451,ipl_hook_rx_sec_mcr.h) */
#include <ipl_hook_rx_sec_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduSec_EMU_EDU_wheelRpmValidMtrSide) */
ICS_PL_RETURN_TYPE PL_Cvt_EduSec_EMU_EDU_wheelRpmValidMtrSide(void)
{
    /* Conversion for RX-Bus-Signal 'EduSec_EMU_EDU_wheelRpmValidMtrSide' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_FLAG bus_cpy;
    ICS_PL_FLAG sys_cpy0 = ICS_PL_FALSE;
    
    
    /* Source-Signal Description: */
    /*     Name: EduSec_EMU_EDU_wheelRpmValidMtrSide(intc_sigcv_rx_sec) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_FLAG, 1 bits, API */
    /*     Desc: Validity flag for the motor-side/Q1 wheel speed" */
    /*     State(s): [0x0...    ] */
    /*     Coded Range: [0x0...0x1] */
    /*     Harmonized Physical Range: [0...1] [NoUnit] */
    /*     Original Physical Range: [0...1] [NoUnit] */
    
    /* Destination-Signal Description: */
    /*     Name: Pl_VehWhlSpdVld1_Sec(intc_sigcv_rx_sec) */
    /*     Category, Type, Interface: TEXT, ICS_PL_FLAG, VAR */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     FALSE [0x0; 0x0] */
    /*     TRUE [0x1; 0x1] */
    /*     Variable-Name: Pl_VehWhlSpdVld1_Sec */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_rx_sec_Mapping00110 */
    /*     Processing: FORCE */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    bus_cpy = ICS_PL_FALSE;
    if(READ_SIGNAL_DATA_API(EduSec_EMU_EDU_wheelRpmValidMtrSide, &bus_cpy) == READ_SIGNAL_DATA_API_SUCCESS)
    {
        
        /* Force PL to perform an 1:1 mapping  */
        if(bus_cpy == ICS_PL_TRUE)
        {
            sys_cpy0 = ICS_PL_TRUE;
        }
        else
        {
            sys_cpy0 = ICS_PL_FALSE;
        }
        /* Copy temporary-dst-container to DST */
        SET_Pl_VehWhlSpdVld1_Sec(sys_cpy0);
    }
    else
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduSec_EMU_EDU_wheelSpeedTarget
/*lint  -efile(451,ipl_hook_rx_sec_mcr.h) */
#include <ipl_hook_rx_sec_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduSec_EMU_EDU_wheelSpeedTarget) */
ICS_PL_RETURN_TYPE PL_Cvt_EduSec_EMU_EDU_wheelSpeedTarget(void)
{
    /* Conversion for RX-Bus-Signal 'EduSec_EMU_EDU_wheelSpeedTarget' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_S16 bus_cpy;
    ICS_PL_S16 sys_cpy0 = 0;
    
    
    /* Source-Signal Description: */
    /*     Name: EduSec_EMU_EDU_wheelSpeedTarget(intc_sigcv_rx_sec) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_S16, 13 bits, API */
    /*     Desc: Wheel Speed Target in Speed Control Mode" */
    /*     State(s): [0x0...    ] */
    /*     Coded Range: [0xF000...0xFE0] */
    /*     Harmonized Physical Range: [-2048...2032] [rpm] */
    /*     Original Physical Range: [-2048...2032] [rpm] */
    
    /* Destination-Signal Description: */
    /*     Name: Pl_VehWhlSpdTgt_Sec(intc_sigcv_rx_sec) */
    /*     Category, Type, Interface: NUM, ICS_PL_S16, VAR */
    /*     Desc: Electrical machine speed requested by main external function */
    /*     Coded Range: [0x8000...0x7FFF] */
    /*     Harmonized Physical Range: [-32768...32767] [PD_rpm] */
    /*     Original Physical Range: [-32768...32767] [rpm] */
    /*     Variable-Name: Pl_VehWhlSpdTgt_Sec */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_rx_sec_Mapping00055 */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    bus_cpy = 0;
    if(READ_SIGNAL_DATA_API(EduSec_EMU_EDU_wheelSpeedTarget, &bus_cpy) == READ_SIGNAL_DATA_API_SUCCESS)
    {
        
        /* Range-Check. Potential violation of SRC.COD_LOWER_LIMIT and SRC.COD_UPPER_LIMIT */
        if((bus_cpy <= 4064) && (bus_cpy >= -4096))
        {
            /* Checking the Source signal range */
            if(bus_cpy < 0)
            {
                /* Conversion of 'EduSec_EMU_EDU_wheelSpeedTarget' to 'Pl_VehWhlSpdTgt_Sec' */
                /*lint -save -e734 */
                sys_cpy0 = (((bus_cpy) - 1) / 2);
                /*lint -restore */
            }
            else
            {
                /* Conversion of 'EduSec_EMU_EDU_wheelSpeedTarget' to 'Pl_VehWhlSpdTgt_Sec' */
                /*lint -save -e734 */
                sys_cpy0 = (((bus_cpy) + 1) / 2);
                /*lint -restore */
            }
        }
        else
        {
            /* SRC is not within the valid COD-range => cancel processing */
            tmp_return_value = ICS_PL_FALSE;
        }
        if(tmp_return_value == ICS_PL_TRUE)
        {
            /* Copy temporary-dst-container to DST */
            SET_Pl_VehWhlSpdTgt_Sec(sys_cpy0);
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduSec_EMU_nmStateReq
/*lint  -efile(451,ipl_hook_rx_sec_mcr.h) */
#include <ipl_hook_rx_sec_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduSec_EMU_nmStateReq) */
ICS_PL_RETURN_TYPE PL_Cvt_EduSec_EMU_nmStateReq(void)
{
    /* Conversion for RX-Bus-Signal 'EduSec_EMU_nmStateReq' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U8 bus_cpy;
    ICS_PL_FLAG sys_cpy0 = ICS_PL_FALSE;
    
    
    /* Source-Signal Description: */
    /*     Name: EduSec_EMU_nmStateReq(intc_sigcv_rx_sec) */
    /*     Category, Type, length, Interface: TEXT, ICS_PL_U8, 4 bits, API */
    /*     Desc:  */
    /*     State(s): [0x0...    ] */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     SLEEP [0x1; 0x1] */
    /*     NORMAL_OPERATION [0x0; 0x0] */
    
    /* Destination-Signal Description: */
    /*     Name: Pl_VehNetMngtReq_Sec(intc_sigcv_rx_sec) */
    /*     Category, Type, Interface: NUM, ICS_PL_FLAG, VAR */
    /*     Desc: Network management state request */
    /*     State(s): [0x0...0x0] */
    /*     Coded Range: [0x00...0x01] */
    /*     Harmonized Physical Range: [0...1] [] */
    /*     Original Physical Range: [0...1] [] */
    /*     Variable-Name: Pl_VehNetMngtReq_Sec */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_rx_sec_Mapping00114 */
    /*     Processing: FORCE */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    bus_cpy = 0U;
    if(READ_SIGNAL_DATA_API(EduSec_EMU_nmStateReq, &bus_cpy) == READ_SIGNAL_DATA_API_SUCCESS)
    {
        
        /* Force PL to perform an 1:1 mapping  */
        if(bus_cpy == 1U)
        {
            sys_cpy0 = ICS_PL_TRUE;
        }
        else
        {
            sys_cpy0 = ICS_PL_FALSE;
        }
        /* Copy temporary-dst-container to DST */
        SET_Pl_VehNetMngtReq_Sec(sys_cpy0);
    }
    else
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduSec_TBC_EMU_inverterInletNorthTemp
/*lint  -efile(451,ipl_hook_rx_sec_mcr.h) */
#include <ipl_hook_rx_sec_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduSec_TBC_EMU_inverterInletNorthTemp) */
ICS_PL_RETURN_TYPE PL_Cvt_EduSec_TBC_EMU_inverterInletNorthTemp(void)
{
    /* Conversion for RX-Bus-Signal 'EduSec_TBC_EMU_inverterInletNorthTemp' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U16 bus_cpy;
    ICS_PL_FLOAT sys_cpy0 = 0.0F;
    
    
    /* Source-Signal Description: */
    /*     Name: EduSec_TBC_EMU_inverterInletNorthTemp(intc_sigcv_rx_sec) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_U16, 11 bits, API */
    /*     Desc: Temperature of the coolant at the inverter inlet. (north) */
    /*     State(s): [0x0...    ] */
    /*     Coded Range: [0x0...0x672] */
    /*     Harmonized Physical Range: [-40...125] [C] */
    /*     Original Physical Range: [-40...125] [C] */
    
    /* Destination-Signal Description: */
    /*     Name: Pl_VehCooltInvInT_North_Sec(intc_sigcv_rx_sec) */
    /*     Category, Type, Interface: NUM, ICS_PL_FLOAT, VAR */
    /*     Desc: Inlet water coolant temperature from external source */
    /*     Harmonized Physical Range: [-40...125] [PD_C] */
    /*     Original Physical Range: [-40...125] [C] */
    /*     Variable-Name: Pl_VehCooltInvInT_North_Sec */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_rx_sec_Mapping00065 */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    bus_cpy = 0U;
    if(READ_SIGNAL_DATA_API(EduSec_TBC_EMU_inverterInletNorthTemp, &bus_cpy) == READ_SIGNAL_DATA_API_SUCCESS)
    {
        
        /* Range-Check. Potential violation of SRC.COD_UPPER_LIMIT */
        if(bus_cpy <= 1650U)
        {
            sys_cpy0 = ((ICS_PL_FLOAT)bus_cpy * ((ICS_PL_FLOAT)0.1)) + ((ICS_PL_FLOAT)-40);

        }
        else
        {
            /* SRC is not within the valid COD-range => cancel processing */
            tmp_return_value = ICS_PL_FALSE;
        }
        if(tmp_return_value == ICS_PL_TRUE)
        {
            /* Copy temporary-dst-container to DST */
            SET_Pl_VehCooltInvInT_North_Sec(sys_cpy0);
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduSec_TBC_EMU_inverterInletSouthTemp
/*lint  -efile(451,ipl_hook_rx_sec_mcr.h) */
#include <ipl_hook_rx_sec_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduSec_TBC_EMU_inverterInletSouthTemp) */
ICS_PL_RETURN_TYPE PL_Cvt_EduSec_TBC_EMU_inverterInletSouthTemp(void)
{
    /* Conversion for RX-Bus-Signal 'EduSec_TBC_EMU_inverterInletSouthTemp' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U16 bus_cpy;
    ICS_PL_FLOAT sys_cpy0 = 0.0F;
    
    
    /* Source-Signal Description: */
    /*     Name: EduSec_TBC_EMU_inverterInletSouthTemp(intc_sigcv_rx_sec) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_U16, 11 bits, API */
    /*     Desc: Temperature of the coolant at the inverter inlet. (south) */
    /*     State(s): [0x0...    ] */
    /*     Coded Range: [0x0...0x672] */
    /*     Harmonized Physical Range: [-40...125] [C] */
    /*     Original Physical Range: [-40...125] [C] */
    
    /* Destination-Signal Description: */
    /*     Name: Pl_VehCooltInvInT_South_Sec(intc_sigcv_rx_sec) */
    /*     Category, Type, Interface: NUM, ICS_PL_FLOAT, VAR */
    /*     Desc: Inlet water coolant temperature from external source */
    /*     Harmonized Physical Range: [-40...125] [PD_C] */
    /*     Original Physical Range: [-40...125] [C] */
    /*     Variable-Name: Pl_VehCooltInvInT_South_Sec */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_rx_sec_Mapping00066 */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    bus_cpy = 0U;
    if(READ_SIGNAL_DATA_API(EduSec_TBC_EMU_inverterInletSouthTemp, &bus_cpy) == READ_SIGNAL_DATA_API_SUCCESS)
    {
        
        /* Range-Check. Potential violation of SRC.COD_UPPER_LIMIT */
        if(bus_cpy <= 1650U)
        {
            sys_cpy0 = ((ICS_PL_FLOAT)bus_cpy * ((ICS_PL_FLOAT)0.1)) + ((ICS_PL_FLOAT)-40);

        }
        else
        {
            /* SRC is not within the valid COD-range => cancel processing */
            tmp_return_value = ICS_PL_FALSE;
        }
        if(tmp_return_value == ICS_PL_TRUE)
        {
            /* Copy temporary-dst-container to DST */
            SET_Pl_VehCooltInvInT_South_Sec(sys_cpy0);
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    
    return tmp_return_value;
}
