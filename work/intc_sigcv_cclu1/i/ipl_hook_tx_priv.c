/****************************************************************************
 * COPYRIGHT VITESCO TECHNOLOGIES GROUP AG (EXCLUSIVE RIGHTS) 
 * Confidential
 * 
 * The reproduction, transmission or use of this document or its
 * contents is not permitted without express written authority.
 * Offenders will be liable for damages. All rights, including rights
 * created by patent grant or registration of a utility model or design,
 * are reserved.
 *---------------------------------------------------------------------------
 * 
 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 * !!! This file is generated by Signal Mapper (SIMA) Code-Generator !!!
 * !!! Do NOT modify this file manually                            !!!
 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 * 
 * Purpose:    PL Hook Implementation
 * 
 * Processor:  independent
 * Tool chain: 
 *    CG-Version:        6.2.0
 *    Schema-Version:    1.18.0
 *    Generation-Date:   05.09.2024  16:24:52  
 *    Generated by user: uiv00534
 * Filename:   $Workfile$
 * Revision:   $Revision: 1.3 $
 * Author:     $Author: Zhang Yi (uiv00534) (uiv00534) $
 * Date:       $Date: 2024/09/06 07:27:52CEST $
 * Changes:    $Log: ipl_hook_tx_priv.c  $
 * Changes:    Revision 1.3 2024/09/06 07:27:52CEST Zhang Yi (uiv00534) (uiv00534) 
 * Changes:    16683028: intc_sigcv_cclu1: doc development and code update
 * 
****************************************************************************/
/*lint -esym(750,IPL_HOOK_TX_PRIV_C) */
#define IPL_HOOK_TX_PRIV_C
#include <intc_sigcv_cclu1_im.h>


#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduPriv_PE_ConCmd
/*lint  -efile(451,ipl_hook_tx_priv_mcr.h) */
#include <ipl_hook_tx_priv_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduPriv_PE_ConCmd) */
ICS_PL_RETURN_TYPE PL_Cvt_EduPriv_PE_ConCmd(void)
{
    /* Conversion for TX-Bus-Signal 'EduPriv_PE_ConCmd' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U8 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: Pl_PeConCmd(intc_sigcv_tx_priv) */
    /*     Category, Type, Interface: TEXT, ICS_PL_U8, VAR */
    /*     Desc: Gearbox clutch engage and disengage mode request */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     NONE_REQ [0x0; 0x0] */
    /*     CFT_DISCNCT [0x1; 0x1] */
    /*     CFT_CNCT [0x2; 0x2] */
    /*     FAST_CNCT [0x3; 0x3] */
    /*     FAST_DISCNCT [0x4; 0x4] */
    /*     Variable-Name: Pl_PeConCmd */
    
    /* Destination-Signal Description: */
    /*     Name: EduPriv_PE_ConCmd(intc_sigcv_tx_priv) */
    /*     Category, Type, length, Interface: TEXT, ICS_PL_U8, 4 bits, API */
    /*     Desc: PE Connection Command */
    /*     State(s): [0x0...    ] */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     Disconnect [0x2; 0x2] */
    /*     Connect [0x1; 0x1] */
    /*     No Request / Error [0x0; 0x0] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_priv_Mapping_PE_ConCmd */
    /*     Processing: BYPASS */
    /*     Bypass-Callout: ByPass_EduPriv_PE_ConCmd */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Init temporary-dst-container */
    bus_cpy = 0U;
    
    /* Bypass PL */
    if(ByPass_EduPriv_PE_ConCmd(GET_Pl_PeConCmd(), &bus_cpy) == ICS_PL_TRUE)
    {
        /* Copy temporary-dst-container to DST */
        if(WRITE_SIGNAL_DATA_API(EduPriv_PE_ConCmd, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
        {
            tmp_return_value = ICS_PL_FALSE;
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduPriv_PE_CosPhi
/*lint  -efile(451,ipl_hook_tx_priv_mcr.h) */
#include <ipl_hook_tx_priv_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduPriv_PE_CosPhi) */
ICS_PL_RETURN_TYPE PL_Cvt_EduPriv_PE_CosPhi(void)
{
    /* Conversion for TX-Bus-Signal 'EduPriv_PE_CosPhi' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U32 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: Pl_FacPwrInvtFil(intc_sigcv_tx_priv) */
    /*     Category, Type, Interface: NUM, ICS_PL_FLOAT, VAR */
    /*     Desc: Filtered power factor value of inverter */
    /*     Harmonized Physical Range: [-1...1] [PD_NoUnit] */
    /*     Original Physical Range: [-1...1] [NoUnit] */
    /*     Variable-Name: Pl_FacPwrInvtFil */
    
    /* Destination-Signal Description: */
    /*     Name: EduPriv_PE_CosPhi(intc_sigcv_tx_priv) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_U32, 32 bits, API */
    /*     Desc: Variable: f32PowFacLpf */
    /*     State(s): [0x0...    ] */
    /*     Coded Range: [0x0...0xFFFFFFFF] */
    /*     Harmonized Physical Range: [-2147483648...2147483647] [NoUnit] */
    /*     Original Physical Range: [-2147483648...2147483647] [NoUnit] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_priv_Mapping_PE_CosPhi */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Init temporary-dst-container */
    bus_cpy = 0U;
    /* Range-Check. Potential violation of SRC.COD_LOWER_LIMIT and SRC.COD_UPPER_LIMIT */
    if((GET_Pl_FacPwrInvtFil() <= 1.0F) && (GET_Pl_FacPwrInvtFil() >= -1.0F))
    {
        ICS_PL_FLOAT temp_float = ((ICS_PL_FLOAT)GET_Pl_FacPwrInvtFil() + (ICS_PL_FLOAT)2147483648);
        bus_cpy = (ICS_PL_U32_ICS_PL_FLOAT)(temp_float);
    }
    else
    {
        /* SRC is not within the valid COD-range => cancel processing */
        tmp_return_value = ICS_PL_FALSE;
    }
    if(tmp_return_value == ICS_PL_TRUE)
    {
        /* Copy temporary-dst-container to DST */
        if(WRITE_SIGNAL_DATA_API(EduPriv_PE_CosPhi, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
        {
            tmp_return_value = ICS_PL_FALSE;
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduPriv_PE_DiodeTemperature
/*lint  -efile(451,ipl_hook_tx_priv_mcr.h) */
#include <ipl_hook_tx_priv_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduPriv_PE_DiodeTemperature) */
ICS_PL_RETURN_TYPE PL_Cvt_EduPriv_PE_DiodeTemperature(void)
{
    /* Conversion for TX-Bus-Signal 'EduPriv_PE_DiodeTemperature' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_S16 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: Pl_TSemcdDiodeInvtMax(intc_sigcv_tx_priv) */
    /*     Category, Type, Interface: NUM, ICS_PL_FLOAT, VAR */
    /*     Desc: Maximum semiconductor temperature of diodes for inverter */
    /*     Harmonized Physical Range: [-273.15...238.8421875] [degC] */
    /*     Original Physical Range: [0...511.9921875] [K] */
    /*     Variable-Name: Pl_TSemcdDiodeInvtMax */
    
    /* Destination-Signal Description: */
    /*     Name: EduPriv_PE_DiodeTemperature(intc_sigcv_tx_priv) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_S16, 14 bits, API */
    /*     Desc: Variable: f32TempDiodeMaxInvt */
    /*     State(s): [0x0...    ] */
    /*     Coded Range: [0xE000...0x1FFF] */
    /*     Harmonized Physical Range: [-819.2...819.1] [°C] */
    /*     Original Physical Range: [-819.2...819.1] [°C] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_priv_Mapping_PE_DiodeTemperature */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Init temporary-dst-container */
    bus_cpy = 0;
    /* Range-Check. Potential violation of SRC.COD_LOWER_LIMIT and SRC.COD_UPPER_LIMIT */
    if((GET_Pl_TSemcdDiodeInvtMax() <= 511.9921875F) && (GET_Pl_TSemcdDiodeInvtMax() >= 0.0F))
    {
        ICS_PL_FLOAT temp_float = ((ICS_PL_FLOAT)GET_Pl_TSemcdDiodeInvtMax() * ((ICS_PL_FLOAT) 10)) + ((ICS_PL_FLOAT)-2731.5);
        bus_cpy = (ICS_PL_S16_ICS_PL_FLOAT)(temp_float);
    }
    else
    {
        /* SRC is not within the valid COD-range => cancel processing */
        tmp_return_value = ICS_PL_FALSE;
    }
    if(tmp_return_value == ICS_PL_TRUE)
    {
        /* Copy temporary-dst-container to DST */
        if(WRITE_SIGNAL_DATA_API(EduPriv_PE_DiodeTemperature, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
        {
            tmp_return_value = ICS_PL_FALSE;
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduPriv_PE_EmRotAg
/*lint  -efile(451,ipl_hook_tx_priv_mcr.h) */
#include <ipl_hook_tx_priv_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduPriv_PE_EmRotAg) */
ICS_PL_RETURN_TYPE PL_Cvt_EduPriv_PE_EmRotAg(void)
{
    /* Conversion for TX-Bus-Signal 'EduPriv_PE_EmRotAg' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U16 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: f32AngRotorEstim(intc_sigcv_tx_priv) */
    /*     Category, Type, Interface: NUM, ICS_PL_FLOAT, VAR */
    /*     Desc: Observer estimated rotor angle */
    /*     Harmonized Physical Range: [0...360] [deg] */
    /*     Original Physical Range: [0...6.283185482025] [rad] */
    /*     Variable-Name: f32AngRotorEstim */
    
    /* Destination-Signal Description: */
    /*     Name: EduPriv_PE_EmRotAg(intc_sigcv_tx_priv) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_U16, 12 bits, API */
    /*     Desc: Actual traction motor rotor angle */
    /*     State(s): [0x0...    ] */
    /*     Coded Range: [0x0...0xFFF] */
    /*     Harmonized Physical Range: [0...359.912109375] [deg] */
    /*     Original Physical Range: [0...359.912109375] [deg] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_priv_Mapping_PE_EmRotAg */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Init temporary-dst-container */
    bus_cpy = 0U;
    /* Range-Check. Potential violation of SRC.COD_LOWER_LIMIT and SRC.COD_UPPER_LIMIT */
    if((GET_f32AngRotorEstim() <= 6.283185482025F) && (GET_f32AngRotorEstim() >= 0.0F))
    {
        /* Limitation Handling. Potential violation of DST.COD_UPPER_LIMIT */
        if(GET_f32AngRotorEstim() <= 6.281652F)
        {
            ICS_PL_FLOAT temp_float = ((ICS_PL_FLOAT)GET_f32AngRotorEstim() * (ICS_PL_FLOAT) 651.89862876368648546621209516338);
            bus_cpy = (ICS_PL_U16_ICS_PL_FLOAT)(temp_float);
        }
        else
        {
            /* Automatically limit to DST.COD_UPPER_LIMIT */
            bus_cpy = 4095U;
        }
    }
    else
    {
        /* SRC is not within the valid COD-range => cancel processing */
        tmp_return_value = ICS_PL_FALSE;
    }
    if(tmp_return_value == ICS_PL_TRUE)
    {
        /* Copy temporary-dst-container to DST */
        if(WRITE_SIGNAL_DATA_API(EduPriv_PE_EmRotAg, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
        {
            tmp_return_value = ICS_PL_FALSE;
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduPriv_PE_EmRotAgVld
/*lint  -efile(451,ipl_hook_tx_priv_mcr.h) */
#include <ipl_hook_tx_priv_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduPriv_PE_EmRotAgVld) */
ICS_PL_RETURN_TYPE PL_Cvt_EduPriv_PE_EmRotAgVld(void)
{
    /* Conversion for TX-Bus-Signal 'EduPriv_PE_EmRotAgVld' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_FLAG bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: Pl_LvStPosnRotorVld(intc_sigcv_tx_priv) */
    /*     Category, Type, Interface: TEXT, ICS_PL_FLAG, VAR */
    /*     Desc: Valid flag for rotor position based on rotor position sensor diagnosis */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     FALSE [0x0; 0x0] */
    /*     TRUE [0x1; 0x1] */
    /*     Variable-Name: Pl_LvStPosnRotorVld */
    
    /* Destination-Signal Description: */
    /*     Name: EduPriv_PE_EmRotAgVld(intc_sigcv_tx_priv) */
    /*     Category, Type, length, Interface: TEXT, ICS_PL_FLAG, 1 bits, API */
    /*     Desc: Valid flag actual traction motor angle */
    /*     State(s): [0x0...    ] */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     Valid [0x1; 0x1] */
    /*     Not Valid [0x0; 0x0] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_priv_Mapping_PE_EmRotAgVld */
    /*     Processing: UNCONDITIONAL */
    /*     Text Mapping */
    /*     SRC -> DST */
    /*     FALSE[0x0] -> Not Valid[0x0] */
    /*     TRUE[0x1] -> Valid[0x1] */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    if(GET_Pl_LvStPosnRotorVld() == ICS_PL_FALSE)
    {
        /* Map SRC-Value 'FALSE' to DST-Value 'Not Valid' */
        bus_cpy = ICS_PL_FALSE;
    }
    else
    {
        /* Map SRC-Value 'TRUE' to DST-Value 'Valid' */
        bus_cpy = ICS_PL_TRUE;
    }
    /* Copy temporary-dst-container to DST */
    if(WRITE_SIGNAL_DATA_API(EduPriv_PE_EmRotAgVld, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduPriv_PE_EmSpd
/*lint  -efile(451,ipl_hook_tx_priv_mcr.h) */
#include <ipl_hook_tx_priv_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduPriv_PE_EmSpd) */
ICS_PL_RETURN_TYPE PL_Cvt_EduPriv_PE_EmSpd(void)
{
    /* Conversion for TX-Bus-Signal 'EduPriv_PE_EmSpd' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U16 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: f32NRotorLpfSlow(intc_sigcv_tx_priv) */
    /*     Category, Type, Interface: NUM, ICS_PL_FLOAT, VAR */
    /*     Desc: Actual rpm from electric machine */
    /*     Harmonized Physical Range: [-32768...32767] [rpm] */
    /*     Original Physical Range: [-32768...32767] [rpm] */
    /*     Variable-Name: f32NRotorLpfSlow */
    
    /* Destination-Signal Description: */
    /*     Name: EduPriv_PE_EmSpd(intc_sigcv_tx_priv) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_U16, 16 bits, API */
    /*     Desc: Actual traction motor speed */
    /*     State(s): [0x7D00...    ] */
    /*     Coded Range: [0x0...0xFFFF] */
    /*     Harmonized Physical Range: [-16000...16767.5] [rpm] */
    /*     Original Physical Range: [-16000...16767.5] [rpm] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_priv_Mapping_PE_EmSpd */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Init temporary-dst-container */
    bus_cpy = 0U;
    /* Range-Check. Potential violation of SRC.COD_LOWER_LIMIT and SRC.COD_UPPER_LIMIT */
    if((GET_f32NRotorLpfSlow() <= 32767.0F) && (GET_f32NRotorLpfSlow() >= -32768.0F))
    {
        /* Limitation Handling. Potential violation of DST.COD_LOWER_LIMIT */
        if(GET_f32NRotorLpfSlow() >= -16000.0F)
        {
            /* Limitation Handling. Potential violation of DST.COD_UPPER_LIMIT */
            if(GET_f32NRotorLpfSlow() <= 16767.5F)
            {
                ICS_PL_FLOAT temp_float = ((ICS_PL_FLOAT)GET_f32NRotorLpfSlow() * ((ICS_PL_FLOAT) 2)) + ((ICS_PL_FLOAT)32000);
                bus_cpy = (ICS_PL_U16_ICS_PL_FLOAT)(temp_float);
            }
            else
            {
                /* Automatically limit to DST.COD_UPPER_LIMIT */
                bus_cpy = 65535U;
            }
        }
        else
        {
            /* Automatically limit to DST.COD_LOWER_LIMIT */
            bus_cpy = 0U;
        }
    }
    else
    {
        /* SRC is not within the valid COD-range => cancel processing */
        tmp_return_value = ICS_PL_FALSE;
    }
    if(tmp_return_value == ICS_PL_TRUE)
    {
        /* Copy temporary-dst-container to DST */
        if(WRITE_SIGNAL_DATA_API(EduPriv_PE_EmSpd, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
        {
            tmp_return_value = ICS_PL_FALSE;
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduPriv_PE_EmSpdVld
/*lint  -efile(451,ipl_hook_tx_priv_mcr.h) */
#include <ipl_hook_tx_priv_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduPriv_PE_EmSpdVld) */
ICS_PL_RETURN_TYPE PL_Cvt_EduPriv_PE_EmSpdVld(void)
{
    /* Conversion for TX-Bus-Signal 'EduPriv_PE_EmSpdVld' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_FLAG bus_cpy;
    
    
    /* Destination-Signal Description: */
    /*     Name: EduPriv_PE_EmSpdVld(intc_sigcv_tx_priv) */
    /*     Category, Type, length, Interface: TEXT, ICS_PL_FLAG, 1 bits, API */
    /*     Desc: Valid flag actual traction motor speed */
    /*     State(s): [0x0...    ] */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     Valid [0x1; 0x1] */
    /*     Not Valid [0x0; 0x0] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_priv_Mapping_PE_EmSpdVld */
    /*     Processing: STUB */
    /*     Stub-Value: Dst-Signal.USER_VALUE */
    /*     Processing-Value-User-Value: 0x1 */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Stub DST to USER_VALUE */
    bus_cpy = ICS_PL_TRUE;
    /* Copy temporary-dst-container to DST */
    if(WRITE_SIGNAL_DATA_API(EduPriv_PE_EmSpdVld, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduPriv_PE_EmTq
/*lint  -efile(451,ipl_hook_tx_priv_mcr.h) */
#include <ipl_hook_tx_priv_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduPriv_PE_EmTq) */
ICS_PL_RETURN_TYPE PL_Cvt_EduPriv_PE_EmTq(void)
{
    /* Conversion for TX-Bus-Signal 'EduPriv_PE_EmTq' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U16 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: Pl_PeEmTq(intc_sigcv_tx_priv) */
    /*     Category, Type, Interface: NUM, ICS_PL_FLOAT, VAR */
    /*     Desc: Filtered estimated electrical machine torque */
    /*     Harmonized Physical Range: [-1024...1023.96875] [PD_Nm] */
    /*     Original Physical Range: [-1024...1023.96875] [Nm] */
    /*     Variable-Name: Pl_PeEmTq */
    
    /* Destination-Signal Description: */
    /*     Name: EduPriv_PE_EmTq(intc_sigcv_tx_priv) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_U16, 12 bits, API */
    /*     Desc: Actual traction motor torque */
    /*     State(s): [0x800...    ] */
    /*     Coded Range: [0x0...0xFFF] */
    /*     Harmonized Physical Range: [-1024...1023.5] [Nm] */
    /*     Original Physical Range: [-1024...1023.5] [Nm] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_priv_Mapping_PE_EmTq */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Init temporary-dst-container */
    bus_cpy = 0U;
    /* Range-Check. Potential violation of SRC.COD_LOWER_LIMIT and SRC.COD_UPPER_LIMIT */
    if((GET_Pl_PeEmTq() <= 1023.96875F) && (GET_Pl_PeEmTq() >= -1024.0F))
    {
        /* Limitation Handling. Potential violation of DST.COD_UPPER_LIMIT */
        if(GET_Pl_PeEmTq() <= 1023.5F)
        {
            ICS_PL_FLOAT temp_float = ((ICS_PL_FLOAT)GET_Pl_PeEmTq() * ((ICS_PL_FLOAT) 2)) + ((ICS_PL_FLOAT)2048);
            bus_cpy = (ICS_PL_U16_ICS_PL_FLOAT)(temp_float);
        }
        else
        {
            /* Automatically limit to DST.COD_UPPER_LIMIT */
            bus_cpy = 4095U;
        }
    }
    else
    {
        /* SRC is not within the valid COD-range => cancel processing */
        tmp_return_value = ICS_PL_FALSE;
    }
    if(tmp_return_value == ICS_PL_TRUE)
    {
        /* Copy temporary-dst-container to DST */
        if(WRITE_SIGNAL_DATA_API(EduPriv_PE_EmTq, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
        {
            tmp_return_value = ICS_PL_FALSE;
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduPriv_PE_EmTqVld
/*lint  -efile(451,ipl_hook_tx_priv_mcr.h) */
#include <ipl_hook_tx_priv_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduPriv_PE_EmTqVld) */
ICS_PL_RETURN_TYPE PL_Cvt_EduPriv_PE_EmTqVld(void)
{
    /* Conversion for TX-Bus-Signal 'EduPriv_PE_EmTqVld' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_FLAG bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: Pl_StQlyTqEmEstim(intc_sigcv_tx_priv) */
    /*     Category, Type, Interface: TEXT, ICS_PL_U8, VAR */
    /*     Desc: Signal qualifier for estimated electrical machine torque */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     OK [0x0; 0x0] */
    /*     NOT_ACT [0x6; 0x6] */
    /*     DEB [0x8; 0x8] */
    /*     INI [0x9; 0x9] */
    /*     NOT_AVL [0xC; 0xC] */
    /*     ERR [0xF; 0xF] */
    /*     Variable-Name: Pl_StQlyTqEmEstim */
    
    /* Destination-Signal Description: */
    /*     Name: EduPriv_PE_EmTqVld(intc_sigcv_tx_priv) */
    /*     Category, Type, length, Interface: TEXT, ICS_PL_FLAG, 1 bits, API */
    /*     Desc: Valid flag actual traction motor torque */
    /*     State(s): [0x0...    ] */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     Valid [0x1; 0x1] */
    /*     Not Valid [0x0; 0x0] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_priv_Mapping_PE_EmTqVld */
    /*     Processing: UNCONDITIONAL */
    /*     Text Mapping */
    /*     SRC -> DST */
    /*     OK[0x0] -> Valid[0x1] */
    /*     NOT_ACT[0x6] -> Not Valid[0x0] */
    /*     DEB[0x8] -> Not Valid[0x0] */
    /*     INI[0x9] -> Not Valid[0x0] */
    /*     NOT_AVL[0xC] -> Not Valid[0x0] */
    /*     ERR[0xF] -> Not Valid[0x0] */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Init temporary-dst-container */
    bus_cpy = ICS_PL_FALSE;
    if(GET_Pl_StQlyTqEmEstim() == 0U)
    {
        /* Map SRC-Value 'OK' to DST-Value 'Valid' */
        bus_cpy = ICS_PL_TRUE;
    }
    else if(GET_Pl_StQlyTqEmEstim() == 6U)
    {
        /* Map SRC-Value 'NOT_ACT' to DST-Value 'Not Valid' */
        bus_cpy = ICS_PL_FALSE;
    }
    else if(GET_Pl_StQlyTqEmEstim() == 8U)
    {
        /* Map SRC-Value 'DEB' to DST-Value 'Not Valid' */
        bus_cpy = ICS_PL_FALSE;
    }
    else if(GET_Pl_StQlyTqEmEstim() == 9U)
    {
        /* Map SRC-Value 'INI' to DST-Value 'Not Valid' */
        bus_cpy = ICS_PL_FALSE;
    }
    else if(GET_Pl_StQlyTqEmEstim() == 12U)
    {
        /* Map SRC-Value 'NOT_AVL' to DST-Value 'Not Valid' */
        bus_cpy = ICS_PL_FALSE;
    }
    else if(GET_Pl_StQlyTqEmEstim() == 15U)
    {
        /* Map SRC-Value 'ERR' to DST-Value 'Not Valid' */
        bus_cpy = ICS_PL_FALSE;
    }
    else
    {
        /* SRC is not within the valid COD-range => cancel processing */
        tmp_return_value = ICS_PL_FALSE;
    }
    if(tmp_return_value == ICS_PL_TRUE)
    {
        /* Copy temporary-dst-container to DST */
        if(WRITE_SIGNAL_DATA_API(EduPriv_PE_EmTqVld, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
        {
            tmp_return_value = ICS_PL_FALSE;
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduPriv_PE_ModulationFactor
/*lint  -efile(451,ipl_hook_tx_priv_mcr.h) */
#include <ipl_hook_tx_priv_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduPriv_PE_ModulationFactor) */
ICS_PL_RETURN_TYPE PL_Cvt_EduPriv_PE_ModulationFactor(void)
{
    /* Conversion for TX-Bus-Signal 'EduPriv_PE_ModulationFactor' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U32 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: Pl_FacMduInvtFil(intc_sigcv_tx_priv) */
    /*     Category, Type, Interface: NUM, ICS_PL_FLOAT, VAR */
    /*     Desc: Filtered modulation factor for inverter */
    /*     Harmonized Physical Range: [-2...2] [PD_NoUnit] */
    /*     Original Physical Range: [-2...2] [NoUnit] */
    /*     Variable-Name: Pl_FacMduInvtFil */
    
    /* Destination-Signal Description: */
    /*     Name: EduPriv_PE_ModulationFactor(intc_sigcv_tx_priv) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_U32, 32 bits, API */
    /*     Desc: Variable: EPWRPR_P_f32MduFacLpf_Value */
    /*     State(s): [0x0...    ] */
    /*     Coded Range: [0x0...0xFFFF] */
    /*     Harmonized Physical Range: [0...65535] [NoUnit] */
    /*     Original Physical Range: [0...65535] [NoUnit] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_priv_Mapping_PE_ModulationFactor */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Init temporary-dst-container */
    bus_cpy = 0U;
    /* Range-Check. Potential violation of SRC.COD_LOWER_LIMIT and SRC.COD_UPPER_LIMIT */
    if((GET_Pl_FacMduInvtFil() <= 2.0F) && (GET_Pl_FacMduInvtFil() >= -2.0F))
    {
        /* Limitation Handling. Potential violation of DST.COD_LOWER_LIMIT */
        if(GET_Pl_FacMduInvtFil() >= 0.0F)
        {
            ICS_PL_FLOAT temp_float = ((ICS_PL_FLOAT)GET_Pl_FacMduInvtFil());
            bus_cpy = (ICS_PL_U32_ICS_PL_FLOAT)(temp_float);
        }
        else
        {
            /* Automatically limit to DST.COD_LOWER_LIMIT */
            bus_cpy = 0U;
        }
    }
    else
    {
        /* SRC is not within the valid COD-range => cancel processing */
        tmp_return_value = ICS_PL_FALSE;
    }
    if(tmp_return_value == ICS_PL_TRUE)
    {
        /* Copy temporary-dst-container to DST */
        if(WRITE_SIGNAL_DATA_API(EduPriv_PE_ModulationFactor, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
        {
            tmp_return_value = ICS_PL_FALSE;
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduPriv_PE_ModulationProcess
/*lint  -efile(451,ipl_hook_tx_priv_mcr.h) */
#include <ipl_hook_tx_priv_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduPriv_PE_ModulationProcess) */
ICS_PL_RETURN_TYPE PL_Cvt_EduPriv_PE_ModulationProcess(void)
{
    /* Conversion for TX-Bus-Signal 'EduPriv_PE_ModulationProcess' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U8 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: Pl_TypPwmInvtOppReq(intc_sigcv_tx_priv) */
    /*     Category, Type, Interface: NUM, ICS_PL_U8, VAR */
    /*     Desc: Inverter PWM modulation type request */
    /*     Coded Range: [0x0...0xB] */
    /*     Harmonized Physical Range: [0...11] [PD_NoUnit] */
    /*     Original Physical Range: [0...11] [NoUnit] */
    /*     Variable-Name: Pl_TypPwmInvtOppReq */
    
    /* Destination-Signal Description: */
    /*     Name: EduPriv_PE_ModulationProcess(intc_sigcv_tx_priv) */
    /*     Category, Type, length, Interface: TEXT, ICS_PL_U8, 8 bits, API */
    /*     Desc: Variable: u8TypPwmMduOppInvt1 */
    /*     State(s): [0x0...    ] */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     SYNCPWM [0x9; 0x9] */
    /*     FBM [0x8; 0x8] */
    /*     DPWM3 [0x7; 0x7] */
    /*     GDPWM [0x6; 0x6] */
    /*     DPWM2 [0x5; 0x5] */
    /*     DPWM1 [0x4; 0x4] */
    /*     DPWM0 [0x3; 0x3] */
    /*     DPWMMAX [0x2; 0x2] */
    /*     DPWMMIN [0x1; 0x1] */
    /*     SVPWM [0x0; 0x0] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_priv_Mapping_PE_ModulationProcess */
    /*     Processing: FORCE */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Force PL to perform an 1:1 mapping  */
    bus_cpy = (ICS_PL_U8)GET_Pl_TypPwmInvtOppReq();
    /* Copy temporary-dst-container to DST */
    if(WRITE_SIGNAL_DATA_API(EduPriv_PE_ModulationProcess, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduPriv_PE_NmAcvnAcu
/*lint  -efile(451,ipl_hook_tx_priv_mcr.h) */
#include <ipl_hook_tx_priv_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduPriv_PE_NmAcvnAcu) */
ICS_PL_RETURN_TYPE PL_Cvt_EduPriv_PE_NmAcvnAcu(void)
{
    /* Conversion for TX-Bus-Signal 'EduPriv_PE_NmAcvnAcu' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U8 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: Pl_PeNmAcvnAcu(intc_sigcv_tx_priv) */
    /*     Category, Type, Interface: TEXT, ICS_PL_U8, VAR */
    /*     State(s): [0x0...0x0] */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     Shutdown [0x0; 0x0] */
    /*     Active [0x1; 0x1] */
    /*     Variable-Name: Pl_PeNmAcvnAcu */
    
    /* Destination-Signal Description: */
    /*     Name: EduPriv_PE_NmAcvnAcu(intc_sigcv_tx_priv) */
    /*     Category, Type, length, Interface: TEXT, ICS_PL_U8, 2 bits, API */
    /*     Desc:  */
    /*     State(s): [0x0...    ] */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     Active [0x1; 0x1] */
    /*     Shutdown [0x0; 0x0] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_priv_Mapping_PE_NmAcvnAcu */
    /*     Processing: UNCONDITIONAL */
    /*     Text Mapping */
    /*     SRC -> DST */
    /*     Shutdown[0x0] -> Shutdown[0x0] */
    /*     Active[0x1] -> Active[0x1] */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Init temporary-dst-container */
    bus_cpy = 0U;
    if(GET_Pl_PeNmAcvnAcu() == 0U)
    {
        /* Map SRC-Value 'Shutdown' to DST-Value 'Shutdown' */
        bus_cpy = 0U;
    }
    else if(GET_Pl_PeNmAcvnAcu() == 1U)
    {
        /* Map SRC-Value 'Active' to DST-Value 'Active' */
        bus_cpy = 1U;
    }
    else
    {
        /* SRC is not within the valid COD-range => cancel processing */
        tmp_return_value = ICS_PL_FALSE;
    }
    if(tmp_return_value == ICS_PL_TRUE)
    {
        /* Copy temporary-dst-container to DST */
        if(WRITE_SIGNAL_DATA_API(EduPriv_PE_NmAcvnAcu, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
        {
            tmp_return_value = ICS_PL_FALSE;
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduPriv_PE_PWMFrequency
/*lint  -efile(451,ipl_hook_tx_priv_mcr.h) */
#include <ipl_hook_tx_priv_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduPriv_PE_PWMFrequency) */
ICS_PL_RETURN_TYPE PL_Cvt_EduPriv_PE_PWMFrequency(void)
{
    /* Conversion for TX-Bus-Signal 'EduPriv_PE_PWMFrequency' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U16 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: f32FrqSwiPwmInvt1(intc_sigcv_tx_priv) */
    /*     Category, Type, Interface: NUM, ICS_PL_FLOAT, VAR */
    /*     Harmonized Physical Range: [0...65535] [Hz] */
    /*     Original Physical Range: [0...65535] [Hz] */
    /*     Variable-Name: f32FrqSwiPwmInvt1 */
    
    /* Destination-Signal Description: */
    /*     Name: EduPriv_PE_PWMFrequency(intc_sigcv_tx_priv) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_U16, 16 bits, API */
    /*     Desc: Variable: u16FrqSwiPwmNxtInvt1 */
    /*     State(s): [0x0...    ] */
    /*     Coded Range: [0x14...0xF424] */
    /*     Harmonized Physical Range: [20...62500] [Hz] */
    /*     Original Physical Range: [20...62500] [Hz] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_priv_Mapping_PE_PWMFrequency */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Init temporary-dst-container */
    bus_cpy = 0U;
    /* Range-Check. Potential violation of SRC.COD_LOWER_LIMIT and SRC.COD_UPPER_LIMIT */
    if((GET_f32FrqSwiPwmInvt1() <= 65535.0F) && (GET_f32FrqSwiPwmInvt1() >= 0.0F))
    {
        /* Limitation Handling. Potential violation of DST.COD_LOWER_LIMIT */
        if(GET_f32FrqSwiPwmInvt1() >= 20.0F)
        {
            /* Limitation Handling. Potential violation of DST.COD_UPPER_LIMIT */
            if(GET_f32FrqSwiPwmInvt1() <= 62500.0F)
            {
                ICS_PL_FLOAT temp_float = ((ICS_PL_FLOAT)GET_f32FrqSwiPwmInvt1());
                bus_cpy = (ICS_PL_U16_ICS_PL_FLOAT)(temp_float);
            }
            else
            {
                /* Automatically limit to DST.COD_UPPER_LIMIT */
                bus_cpy = 62500U;
            }
        }
        else
        {
            /* Automatically limit to DST.COD_LOWER_LIMIT */
            bus_cpy = 20U;
        }
    }
    else
    {
        /* SRC is not within the valid COD-range => cancel processing */
        tmp_return_value = ICS_PL_FALSE;
    }
    if(tmp_return_value == ICS_PL_TRUE)
    {
        /* Copy temporary-dst-container to DST */
        if(WRITE_SIGNAL_DATA_API(EduPriv_PE_PWMFrequency, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
        {
            tmp_return_value = ICS_PL_FALSE;
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduPriv_PE_PhaseCurrent
/*lint  -efile(451,ipl_hook_tx_priv_mcr.h) */
#include <ipl_hook_tx_priv_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduPriv_PE_PhaseCurrent) */
ICS_PL_RETURN_TYPE PL_Cvt_EduPriv_PE_PhaseCurrent(void)
{
    /* Conversion for TX-Bus-Signal 'EduPriv_PE_PhaseCurrent' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U32 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: Pl_IRmsPha3FilInvt(intc_sigcv_tx_priv) */
    /*     Category, Type, Interface: NUM, ICS_PL_FLOAT, VAR */
    /*     Desc: Filtered root mean square current of phase 3 of inverter */
    /*     Harmonized Physical Range: [-2048...2047.9375] [PD_A] */
    /*     Original Physical Range: [-2048...2047.9375] [A] */
    /*     Variable-Name: Pl_IRmsPha3FilInvt */
    
    /* Destination-Signal Description: */
    /*     Name: EduPriv_PE_PhaseCurrent(intc_sigcv_tx_priv) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_U32, 32 bits, API */
    /*     Desc: Variable: EPWRPR_P_f32CurrRms3PhaLpf_Value */
    /*     State(s): [0x800...    ] */
    /*     Coded Range: [0x0...0x1000] */
    /*     Harmonized Physical Range: [-1375...1375] [A] */
    /*     Original Physical Range: [-1375...1375] [A] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_priv_Mapping_PE_PhaseCurrent */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Init temporary-dst-container */
    bus_cpy = 0U;
    /* Range-Check. Potential violation of SRC.COD_LOWER_LIMIT and SRC.COD_UPPER_LIMIT */
    if((GET_Pl_IRmsPha3FilInvt() <= 2047.9375F) && (GET_Pl_IRmsPha3FilInvt() >= -2048.0F))
    {
        /* Limitation Handling. Potential violation of DST.COD_LOWER_LIMIT */
        if(GET_Pl_IRmsPha3FilInvt() >= -1375.0F)
        {
            /* Limitation Handling. Potential violation of DST.COD_UPPER_LIMIT */
            if(GET_Pl_IRmsPha3FilInvt() <= 1375.0F)
            {
                ICS_PL_FLOAT temp_float = ((ICS_PL_FLOAT)GET_Pl_IRmsPha3FilInvt() * ((ICS_PL_FLOAT) 1.48945454545454545454545454545)) + ((ICS_PL_FLOAT)2048);
                bus_cpy = (ICS_PL_U32_ICS_PL_FLOAT)(temp_float);
            }
            else
            {
                /* Automatically limit to DST.COD_UPPER_LIMIT */
                bus_cpy = 4096U;
            }
        }
        else
        {
            /* Automatically limit to DST.COD_LOWER_LIMIT */
            bus_cpy = 0U;
        }
    }
    else
    {
        /* SRC is not within the valid COD-range => cancel processing */
        tmp_return_value = ICS_PL_FALSE;
    }
    if(tmp_return_value == ICS_PL_TRUE)
    {
        /* Copy temporary-dst-container to DST */
        if(WRITE_SIGNAL_DATA_API(EduPriv_PE_PhaseCurrent, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
        {
            tmp_return_value = ICS_PL_FALSE;
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduPriv_PE_SpdCtrlCfmd
/*lint  -efile(451,ipl_hook_tx_priv_mcr.h) */
#include <ipl_hook_tx_priv_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduPriv_PE_SpdCtrlCfmd) */
ICS_PL_RETURN_TYPE PL_Cvt_EduPriv_PE_SpdCtrlCfmd(void)
{
    /* Conversion for TX-Bus-Signal 'EduPriv_PE_SpdCtrlCfmd' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U8 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: Pl_PeSpdCtlCfm(intc_sigcv_tx_priv) */
    /*     Category, Type, Interface: TEXT, ICS_PL_U8, VAR */
    /*     Desc: Electrical machine speed control confirmation status */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     NOT_AVL [0x0; 0x0] */
    /*     AVL [0x1; 0x1] */
    /*     CFM [0x2; 0x2] */
    /*     CNCL [0x3; 0x3] */
    /*     Variable-Name: Pl_PeSpdCtlCfm */
    
    /* Destination-Signal Description: */
    /*     Name: EduPriv_PE_SpdCtrlCfmd(intc_sigcv_tx_priv) */
    /*     Category, Type, length, Interface: TEXT, ICS_PL_U8, 4 bits, API */
    /*     Desc: Speed control confirmation */
    /*     State(s): [0x0...    ] */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     Denied [0x3; 0x3] */
    /*     Confirmed [0x2; 0x2] */
    /*     Available [0x1; 0x1] */
    /*     Unavailable [0x0; 0x0] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_priv_Mapping_PE_SpdCtrlCfmd */
    /*     Processing: UNCONDITIONAL */
    /*     Text Mapping */
    /*     SRC -> DST */
    /*     NOT_AVL[0x0] -> Unavailable[0x0] */
    /*     AVL[0x1] -> Available[0x1] */
    /*     CFM[0x2] -> Confirmed[0x2] */
    /*     CNCL[0x3] -> Denied[0x3] */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Init temporary-dst-container */
    bus_cpy = 0U;
    if(GET_Pl_PeSpdCtlCfm() == 0U)
    {
        /* Map SRC-Value 'NOT_AVL' to DST-Value 'Unavailable' */
        bus_cpy = 0U;
    }
    else if(GET_Pl_PeSpdCtlCfm() == 1U)
    {
        /* Map SRC-Value 'AVL' to DST-Value 'Available' */
        bus_cpy = 1U;
    }
    else if(GET_Pl_PeSpdCtlCfm() == 2U)
    {
        /* Map SRC-Value 'CFM' to DST-Value 'Confirmed' */
        bus_cpy = 2U;
    }
    else if(GET_Pl_PeSpdCtlCfm() == 3U)
    {
        /* Map SRC-Value 'CNCL' to DST-Value 'Denied' */
        bus_cpy = 3U;
    }
    else
    {
        /* SRC is not within the valid COD-range => cancel processing */
        tmp_return_value = ICS_PL_FALSE;
    }
    if(tmp_return_value == ICS_PL_TRUE)
    {
        /* Copy temporary-dst-container to DST */
        if(WRITE_SIGNAL_DATA_API(EduPriv_PE_SpdCtrlCfmd, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
        {
            tmp_return_value = ICS_PL_FALSE;
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduPriv_PE_StateInv
/*lint  -efile(451,ipl_hook_tx_priv_mcr.h) */
#include <ipl_hook_tx_priv_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduPriv_PE_StateInv) */
ICS_PL_RETURN_TYPE PL_Cvt_EduPriv_PE_StateInv(void)
{
    /* Conversion for TX-Bus-Signal 'EduPriv_PE_StateInv' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U8 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: Pl_StEmInvtReq(intc_sigcv_tx_priv) */
    /*     Category, Type, Interface: BITFIELD, ICS_PL_U16, VAR */
    /*     Desc: Requested electrical machine state for the inverter */
    /*     BitField definitions (Name [Mask, CompareValue]) */
    /*     ERR [0xE000; 0xE000] */
    /*     UKWN_6 [0xE000; 0xC000] */
    /*     UKWN_5 [0xE000; 0xA000] */
    /*     EM_CHA [0xE000; 0x8000] */
    /*     POSN_CAL [0xE000; 0x6000] */
    /*     CTL [0xE000; 0x4000] */
    /*     IDLE [0xE000; 0x2000] */
    /*     NOT_AVL [0xE000; 0x0] */
    /*     UKWN_31 [0x1F00; 0x1F00] */
    /*     UKWN_30 [0x1F00; 0x1E00] */
    /*     UKWN_29 [0x1F00; 0x1D00] */
    /*     UKWN_28 [0x1F00; 0x1C00] */
    /*     UKWN_27 [0x1F00; 0x1B00] */
    /*     UKWN_26 [0x1F00; 0x1A00] */
    /*     UKWN_25 [0x1F00; 0x1900] */
    /*     UKWN_24 [0x1F00; 0x1800] */
    /*     UKWN_23 [0x1F00; 0x1700] */
    /*     UKWN_22 [0x1F00; 0x1600] */
    /*     UKWN_21 [0x1F00; 0x1500] */
    /*     UKWN_20 [0x1F00; 0x1400] */
    /*     UKWN_19 [0x1F00; 0x1300] */
    /*     ERR_CTL_TQ_0 [0x1F00; 0x1200] */
    /*     ERR_FW [0x1F00; 0x1100] */
    /*     ERR_SHO_ACT [0x1F00; 0x1000] */
    /*     POSN_CAL_UKWN [0x1F00; 0xF00] */
    /*     POSN_CAL_INI [0x1F00; 0xE00] */
    /*     POSN_CAL_PAS [0x1F00; 0xD00] */
    /*     POSN_CAL_ACT [0x1F00; 0xC00] */
    /*     CTL_TRAN_IDLE [0x1F00; 0xB00] */
    /*     CTL_TQ_0 [0x1F00; 0xA00] */
    /*     CTL_DCHA_DCV [0x1F00; 0x900] */
    /*     CTL_I_DCV [0x1F00; 0x800] */
    /*     CTL_U_DCV [0x1F00; 0x700] */
    /*     CTL_N [0x1F00; 0x600] */
    /*     CTL_TQ [0x1F00; 0x500] */
    /*     IDLE_INI_CTL [0x1F00; 0x400] */
    /*     IDLE_WAIT_REQ [0x1F00; 0x300] */
    /*     IDLE_FW [0x1F00; 0x200] */
    /*     IDLE_SHO_ACT [0x1F00; 0x100] */
    /*     NOT_AVL_ST_EM_1 [0x1F00; 0x0] */
    /*     UKWN [0x60; 0x60] */
    /*     N_CTL_EXT [0x60; 0x40] */
    /*     N_CTL_IT [0x60; 0x20] */
    /*     NOT_AVL_ST_EM_2 [0x60; 0x0] */
    /*     INVT_ACT [0xC; 0xC] */
    /*     INVT_FW [0xC; 0x8] */
    /*     INVT_SHO_ACT [0xC; 0x4] */
    /*     INVT_WAIT_REQ [0xC; 0x0] */
    /*     SHO_ACT [0x3; 0x3] */
    /*     SHO_ACT_HI_SIDE [0x3; 0x2] */
    /*     SHO_ACT_LO_SIDE [0x3; 0x1] */
    /*     NOT_AVL_ST_INVT_2 [0x3; 0x0] */
    /*     Variable-Name: Pl_StEmInvtReq */
    
    /* Destination-Signal Description: */
    /*     Name: EduPriv_PE_StateInv(intc_sigcv_tx_priv) */
    /*     Category, Type, length, Interface: TEXT, ICS_PL_U8, 8 bits, API */
    /*     Desc: Variable: EETQMG_P_u8StateInvt1Ema_Value */
    /*     State(s): [0x0...    ] */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     ERR [0x7; 0x7] */
    /*     UKWN_6 [0x6; 0x6] */
    /*     UKWN_5 [0x5; 0x5] */
    /*     EM_CHA [0x4; 0x4] */
    /*     POSN_CTL [0x3; 0x3] */
    /*     CTL [0x2; 0x2] */
    /*     IDLE [0x1; 0x1] */
    /*     NOT_AVL [0x0; 0x0] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_priv_Mapping_PE_StateInv */
    /*     Processing: UNCONDITIONAL */
    /*     Bitfield Mapping */
    /*     SRC -> DST */
    /*     NOT_AVL[0xE000 = 0x0] -> NOT_AVL[0x0] */
    /*     IDLE[0xE000 = 0x2000] -> IDLE[0x1] */
    /*     CTL[0xE000 = 0x4000] -> CTL[0x2] */
    /*     POSN_CAL[0xE000 = 0x6000] -> POSN_CTL[0x3] */
    /*     EM_CHA[0xE000 = 0x8000] -> EM_CHA[0x4] */
    /*     UKWN_5[0xE000 = 0xA000] -> UKWN_5[0x5] */
    /*     UKWN_6[0xE000 = 0xC000] -> UKWN_6[0x6] */
    /*     ERR[0xE000 = 0xE000] -> ERR[0x7] */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    /* Init temporary-dst-container */
    bus_cpy = 0U;
    
    if((GET_Pl_StEmInvtReq() & 57344U) == 0U)
    {
        /* Map SRC-Value 'NOT_AVL' to DST-Value 'NOT_AVL' */
        bus_cpy = 0U;
    }
    else if((GET_Pl_StEmInvtReq() & 57344U) == 8192U)
    {
        /* Map SRC-Value 'IDLE' to DST-Value 'IDLE' */
        bus_cpy = 1U;
    }
    else if((GET_Pl_StEmInvtReq() & 57344U) == 16384U)
    {
        /* Map SRC-Value 'CTL' to DST-Value 'CTL' */
        bus_cpy = 2U;
    }
    else if((GET_Pl_StEmInvtReq() & 57344U) == 24576U)
    {
        /* Map SRC-Value 'POSN_CAL' to DST-Value 'POSN_CTL' */
        bus_cpy = 3U;
    }
    else if((GET_Pl_StEmInvtReq() & 57344U) == 32768U)
    {
        /* Map SRC-Value 'EM_CHA' to DST-Value 'EM_CHA' */
        bus_cpy = 4U;
    }
    else if((GET_Pl_StEmInvtReq() & 57344U) == 40960U)
    {
        /* Map SRC-Value 'UKWN_5' to DST-Value 'UKWN_5' */
        bus_cpy = 5U;
    }
    else if((GET_Pl_StEmInvtReq() & 57344U) == 49152U)
    {
        /* Map SRC-Value 'UKWN_6' to DST-Value 'UKWN_6' */
        bus_cpy = 6U;
    }
    else if((GET_Pl_StEmInvtReq() & 57344U) == 57344U)
    {
        /* Map SRC-Value 'ERR' to DST-Value 'ERR' */
        bus_cpy = 7U;
    }
    else
    {
        /* SRC is not within the valid COD-range => cancel processing */
        tmp_return_value = ICS_PL_FALSE;
    }
    if(tmp_return_value == ICS_PL_TRUE)
    {
        /* Copy temporary-dst-container to DST */
        if(WRITE_SIGNAL_DATA_API(EduPriv_PE_StateInv, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
        {
            tmp_return_value = ICS_PL_FALSE;
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduPriv_PE_TjunctionTemperature
/*lint  -efile(451,ipl_hook_tx_priv_mcr.h) */
#include <ipl_hook_tx_priv_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduPriv_PE_TjunctionTemperature) */
ICS_PL_RETURN_TYPE PL_Cvt_EduPriv_PE_TjunctionTemperature(void)
{
    /* Conversion for TX-Bus-Signal 'EduPriv_PE_TjunctionTemperature' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_S16 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: Pl_TSemcdPwrSwiDiodeInvtMax(intc_sigcv_tx_priv) */
    /*     Category, Type, Interface: NUM, ICS_PL_FLOAT, VAR */
    /*     Desc: Maximum semiconductor temperature of power switches and diodes for inverter */
    /*     Harmonized Physical Range: [-273.15...238.8421875] [degC] */
    /*     Original Physical Range: [0...511.9921875] [K] */
    /*     Variable-Name: Pl_TSemcdPwrSwiDiodeInvtMax */
    
    /* Destination-Signal Description: */
    /*     Name: EduPriv_PE_TjunctionTemperature(intc_sigcv_tx_priv) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_S16, 14 bits, API */
    /*     Desc: Variable: EPWRPR_P_f32TempTjcInvt_Value */
    /*     State(s): [0x0...    ] */
    /*     Coded Range: [0xE000...0x1FFF] */
    /*     Harmonized Physical Range: [-819.2...819.1] [°C] */
    /*     Original Physical Range: [-819.2...819.1] [°C] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_priv_Mapping_PE_TjunctionTemperature */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Init temporary-dst-container */
    bus_cpy = 0;
    /* Range-Check. Potential violation of SRC.COD_LOWER_LIMIT and SRC.COD_UPPER_LIMIT */
    if((GET_Pl_TSemcdPwrSwiDiodeInvtMax() <= 511.9921875F) && (GET_Pl_TSemcdPwrSwiDiodeInvtMax() >= 0.0F))
    {
        ICS_PL_FLOAT temp_float = ((ICS_PL_FLOAT)GET_Pl_TSemcdPwrSwiDiodeInvtMax() * ((ICS_PL_FLOAT) 10)) + ((ICS_PL_FLOAT)-2731.5);
        bus_cpy = (ICS_PL_S16_ICS_PL_FLOAT)(temp_float);
    }
    else
    {
        /* SRC is not within the valid COD-range => cancel processing */
        tmp_return_value = ICS_PL_FALSE;
    }
    if(tmp_return_value == ICS_PL_TRUE)
    {
        /* Copy temporary-dst-container to DST */
        if(WRITE_SIGNAL_DATA_API(EduPriv_PE_TjunctionTemperature, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
        {
            tmp_return_value = ICS_PL_FALSE;
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduPriv_PE_TqCtrlCfmd
/*lint  -efile(451,ipl_hook_tx_priv_mcr.h) */
#include <ipl_hook_tx_priv_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduPriv_PE_TqCtrlCfmd) */
ICS_PL_RETURN_TYPE PL_Cvt_EduPriv_PE_TqCtrlCfmd(void)
{
    /* Conversion for TX-Bus-Signal 'EduPriv_PE_TqCtrlCfmd' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U8 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: Pl_PeTqCtlCfm(intc_sigcv_tx_priv) */
    /*     Category, Type, Interface: TEXT, ICS_PL_U8, VAR */
    /*     Desc: Electrical machine torque control confirmation status */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     NOT_AVL [0x0; 0x0] */
    /*     AVL [0x1; 0x1] */
    /*     CFM [0x2; 0x2] */
    /*     CNCL [0x3; 0x3] */
    /*     Variable-Name: Pl_PeTqCtlCfm */
    
    /* Destination-Signal Description: */
    /*     Name: EduPriv_PE_TqCtrlCfmd(intc_sigcv_tx_priv) */
    /*     Category, Type, length, Interface: TEXT, ICS_PL_U8, 4 bits, API */
    /*     Desc: Torque control confirmation */
    /*     State(s): [0x0...    ] */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     Denied [0x3; 0x3] */
    /*     Confirmed [0x2; 0x2] */
    /*     Available [0x1; 0x1] */
    /*     Unavailable [0x0; 0x0] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_priv_Mapping_PE_TqCtrlCfmd */
    /*     Processing: UNCONDITIONAL */
    /*     Text Mapping */
    /*     SRC -> DST */
    /*     NOT_AVL[0x0] -> Unavailable[0x0] */
    /*     AVL[0x1] -> Available[0x1] */
    /*     CFM[0x2] -> Confirmed[0x2] */
    /*     CNCL[0x3] -> Denied[0x3] */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Init temporary-dst-container */
    bus_cpy = 0U;
    if(GET_Pl_PeTqCtlCfm() == 0U)
    {
        /* Map SRC-Value 'NOT_AVL' to DST-Value 'Unavailable' */
        bus_cpy = 0U;
    }
    else if(GET_Pl_PeTqCtlCfm() == 1U)
    {
        /* Map SRC-Value 'AVL' to DST-Value 'Available' */
        bus_cpy = 1U;
    }
    else if(GET_Pl_PeTqCtlCfm() == 2U)
    {
        /* Map SRC-Value 'CFM' to DST-Value 'Confirmed' */
        bus_cpy = 2U;
    }
    else if(GET_Pl_PeTqCtlCfm() == 3U)
    {
        /* Map SRC-Value 'CNCL' to DST-Value 'Denied' */
        bus_cpy = 3U;
    }
    else
    {
        /* SRC is not within the valid COD-range => cancel processing */
        tmp_return_value = ICS_PL_FALSE;
    }
    if(tmp_return_value == ICS_PL_TRUE)
    {
        /* Copy temporary-dst-container to DST */
        if(WRITE_SIGNAL_DATA_API(EduPriv_PE_TqCtrlCfmd, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
        {
            tmp_return_value = ICS_PL_FALSE;
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduPriv_PE_WaterTemperature
/*lint  -efile(451,ipl_hook_tx_priv_mcr.h) */
#include <ipl_hook_tx_priv_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduPriv_PE_WaterTemperature) */
ICS_PL_RETURN_TYPE PL_Cvt_EduPriv_PE_WaterTemperature(void)
{
    /* Conversion for TX-Bus-Signal 'EduPriv_PE_WaterTemperature' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U16 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: Pl_TWtrCoolIn(intc_sigcv_tx_priv) */
    /*     Category, Type, Interface: NUM, ICS_PL_U16, VAR */
    /*     Desc: Inlet water coolant temperature */
    /*     Coded Range: [0x0...0xFFFF] */
    /*     Harmonized Physical Range: [-273.15...238.8421875] [degC] */
    /*     Original Physical Range: [0...511.9921875] [K] */
    /*     Variable-Name: Pl_TWtrCoolIn */
    
    /* Destination-Signal Description: */
    /*     Name: EduPriv_PE_WaterTemperature(intc_sigcv_tx_priv) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_U16, 16 bits, API */
    /*     Desc: Variable: ECOLSD_P_s16TempCoolIn_Value */
    /*     State(s): [0x0...    ] */
    /*     Coded Range: [0x0...0xFFFF] */
    /*     Harmonized Physical Range: [-273.15...238.8421875] [°C] */
    /*     Original Physical Range: [-273.15...238.8421875] [°C] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_priv_Mapping_PE_WaterTemperature */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Conversion of 'Pl_TWtrCoolIn' to 'EduPriv_PE_WaterTemperature' */
    /*lint -save -e734 */
    bus_cpy = GET_Pl_TWtrCoolIn();
    /*lint -restore */
    /* Copy temporary-dst-container to DST */
    if(WRITE_SIGNAL_DATA_API(EduPriv_PE_WaterTemperature, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduPriv_PE_WhlSpd1
/*lint  -efile(451,ipl_hook_tx_priv_mcr.h) */
#include <ipl_hook_tx_priv_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduPriv_PE_WhlSpd1) */
ICS_PL_RETURN_TYPE PL_Cvt_EduPriv_PE_WhlSpd1(void)
{
    /* Conversion for TX-Bus-Signal 'EduPriv_PE_WhlSpd1' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_S16 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: Pl_WhlSpdMeasd1(intc_sigcv_tx_priv) */
    /*     Category, Type, Interface: NUM, ICS_PL_FLOAT, VAR */
    /*     Harmonized Physical Range: [-2048...2047.75] [rpm] */
    /*     Original Physical Range: [-2048...2047.75] [rpm] */
    /*     Variable-Name: Pl_WhlSpdMeasd1 */
    
    /* Destination-Signal Description: */
    /*     Name: EduPriv_PE_WhlSpd1(intc_sigcv_tx_priv) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_S16, 14 bits, API */
    /*     Desc: Speed of wheel 1 */
    /*     State(s): [0x0...    ] */
    /*     Coded Range: [0xE000...0x1FFF] */
    /*     Harmonized Physical Range: [-2048...2047.75] [rpm] */
    /*     Original Physical Range: [-2048...2047.75] [rpm] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_priv_Mapping_PE_WhlSpd1 */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Init temporary-dst-container */
    bus_cpy = 0;
    /* Range-Check. Potential violation of SRC.COD_LOWER_LIMIT and SRC.COD_UPPER_LIMIT */
    if((GET_Pl_WhlSpdMeasd1() <= 2047.75F) && (GET_Pl_WhlSpdMeasd1() >= -2048.0F))
    {
        ICS_PL_FLOAT temp_float = ((ICS_PL_FLOAT)GET_Pl_WhlSpdMeasd1() * (ICS_PL_FLOAT) 4);
        bus_cpy = (ICS_PL_S16_ICS_PL_FLOAT)(temp_float);
    }
    else
    {
        /* SRC is not within the valid COD-range => cancel processing */
        tmp_return_value = ICS_PL_FALSE;
    }
    if(tmp_return_value == ICS_PL_TRUE)
    {
        /* Copy temporary-dst-container to DST */
        if(WRITE_SIGNAL_DATA_API(EduPriv_PE_WhlSpd1, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
        {
            tmp_return_value = ICS_PL_FALSE;
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduPriv_PE_WhlSpd2
/*lint  -efile(451,ipl_hook_tx_priv_mcr.h) */
#include <ipl_hook_tx_priv_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduPriv_PE_WhlSpd2) */
ICS_PL_RETURN_TYPE PL_Cvt_EduPriv_PE_WhlSpd2(void)
{
    /* Conversion for TX-Bus-Signal 'EduPriv_PE_WhlSpd2' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_S16 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: Pl_WhlSpdMeasd2(intc_sigcv_tx_priv) */
    /*     Category, Type, Interface: NUM, ICS_PL_FLOAT, VAR */
    /*     Harmonized Physical Range: [-2048...2047.75] [rpm] */
    /*     Original Physical Range: [-2048...2047.75] [rpm] */
    /*     Variable-Name: Pl_WhlSpdMeasd2 */
    
    /* Destination-Signal Description: */
    /*     Name: EduPriv_PE_WhlSpd2(intc_sigcv_tx_priv) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_S16, 14 bits, API */
    /*     Desc: Speed of wheel 2 */
    /*     State(s): [0x0...    ] */
    /*     Coded Range: [0xE000...0x1FFF] */
    /*     Harmonized Physical Range: [-2048...2047.75] [rpm] */
    /*     Original Physical Range: [-2048...2047.75] [rpm] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_priv_Mapping_PE_WhlSpd2 */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Init temporary-dst-container */
    bus_cpy = 0;
    /* Range-Check. Potential violation of SRC.COD_LOWER_LIMIT and SRC.COD_UPPER_LIMIT */
    if((GET_Pl_WhlSpdMeasd2() <= 2047.75F) && (GET_Pl_WhlSpdMeasd2() >= -2048.0F))
    {
        ICS_PL_FLOAT temp_float = ((ICS_PL_FLOAT)GET_Pl_WhlSpdMeasd2() * (ICS_PL_FLOAT) 4);
        bus_cpy = (ICS_PL_S16_ICS_PL_FLOAT)(temp_float);
    }
    else
    {
        /* SRC is not within the valid COD-range => cancel processing */
        tmp_return_value = ICS_PL_FALSE;
    }
    if(tmp_return_value == ICS_PL_TRUE)
    {
        /* Copy temporary-dst-container to DST */
        if(WRITE_SIGNAL_DATA_API(EduPriv_PE_WhlSpd2, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
        {
            tmp_return_value = ICS_PL_FALSE;
        }
        else
        {
            /* Nothing to do here */
        }
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduPriv_PE_WhlSpdVld1
/*lint  -efile(451,ipl_hook_tx_priv_mcr.h) */
#include <ipl_hook_tx_priv_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduPriv_PE_WhlSpdVld1) */
ICS_PL_RETURN_TYPE PL_Cvt_EduPriv_PE_WhlSpdVld1(void)
{
    /* Conversion for TX-Bus-Signal 'EduPriv_PE_WhlSpdVld1' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_FLAG bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: Pl_WhlSpdMeasdVld1(intc_sigcv_tx_priv) */
    /*     Category, Type, Interface: TEXT, ICS_PL_FLAG, VAR */
    /*     State(s): [0x0...0x0] */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     Valid [0x1; 0x1] */
    /*     Not Valid [0x0; 0x0] */
    /*     Variable-Name: Pl_WhlSpdMeasdVld1 */
    
    /* Destination-Signal Description: */
    /*     Name: EduPriv_PE_WhlSpdVld1(intc_sigcv_tx_priv) */
    /*     Category, Type, length, Interface: TEXT, ICS_PL_FLAG, 1 bits, API */
    /*     Desc: Validity flag for the wheel 1 speed */
    /*     State(s): [0x0...    ] */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     Valid [0x1; 0x1] */
    /*     Not Valid [0x0; 0x0] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_priv_Mapping_PE_WhlSpdVld1 */
    /*     Processing: UNCONDITIONAL */
    /*     Text Mapping */
    /*     SRC -> DST */
    /*     Not Valid[0x0] -> Not Valid[0x0] */
    /*     Valid[0x1] -> Valid[0x1] */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    if(GET_Pl_WhlSpdMeasdVld1() == ICS_PL_FALSE)
    {
        /* Map SRC-Value 'Not Valid' to DST-Value 'Not Valid' */
        bus_cpy = ICS_PL_FALSE;
    }
    else
    {
        /* Map SRC-Value 'Valid' to DST-Value 'Valid' */
        bus_cpy = ICS_PL_TRUE;
    }
    /* Copy temporary-dst-container to DST */
    if(WRITE_SIGNAL_DATA_API(EduPriv_PE_WhlSpdVld1, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduPriv_PE_WhlSpdVld2
/*lint  -efile(451,ipl_hook_tx_priv_mcr.h) */
#include <ipl_hook_tx_priv_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduPriv_PE_WhlSpdVld2) */
ICS_PL_RETURN_TYPE PL_Cvt_EduPriv_PE_WhlSpdVld2(void)
{
    /* Conversion for TX-Bus-Signal 'EduPriv_PE_WhlSpdVld2' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_FLAG bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: Pl_WhlSpdMeasdVld2(intc_sigcv_tx_priv) */
    /*     Category, Type, Interface: TEXT, ICS_PL_FLAG, VAR */
    /*     State(s): [0x0...0x0] */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     Valid [0x1; 0x1] */
    /*     Not Valid [0x0; 0x0] */
    /*     Variable-Name: Pl_WhlSpdMeasdVld2 */
    
    /* Destination-Signal Description: */
    /*     Name: EduPriv_PE_WhlSpdVld2(intc_sigcv_tx_priv) */
    /*     Category, Type, length, Interface: TEXT, ICS_PL_FLAG, 1 bits, API */
    /*     Desc: Validity flag for the wheel 2 speed */
    /*     State(s): [0x0...    ] */
    /*     Text definitions (Name [CLL, CUL]) */
    /*     Valid [0x1; 0x1] */
    /*     Not Valid [0x0; 0x0] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_priv_Mapping_PE_WhlSpdVld2 */
    /*     Processing: UNCONDITIONAL */
    /*     Text Mapping */
    /*     SRC -> DST */
    /*     Not Valid[0x0] -> Not Valid[0x0] */
    /*     Valid[0x1] -> Valid[0x1] */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    if(GET_Pl_WhlSpdMeasdVld2() == ICS_PL_FALSE)
    {
        /* Map SRC-Value 'Not Valid' to DST-Value 'Not Valid' */
        bus_cpy = ICS_PL_FALSE;
    }
    else
    {
        /* Map SRC-Value 'Valid' to DST-Value 'Valid' */
        bus_cpy = ICS_PL_TRUE;
    }
    /* Copy temporary-dst-container to DST */
    if(WRITE_SIGNAL_DATA_API(EduPriv_PE_WhlSpdVld2, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduPriv_PE_aeIdfLstActErrFmyMon0
/*lint  -efile(451,ipl_hook_tx_priv_mcr.h) */
#include <ipl_hook_tx_priv_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduPriv_PE_aeIdfLstActErrFmyMon0) */
ICS_PL_RETURN_TYPE PL_Cvt_EduPriv_PE_aeIdfLstActErrFmyMon0(void)
{
    /* Conversion for TX-Bus-Signal 'EduPriv_PE_aeIdfLstActErrFmyMon0' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U8 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: aeIdfLstActErrFmyMon[8](intc_sigcv_tx_priv) */
    /*     Category, Type, Interface: NUM, ICS_PL_U8, VAR */
    /*     State(s): [0x0...0x0] */
    /*     Coded Range: [0x00...0xFF] */
    /*     Harmonized Physical Range: [0...255] [] */
    /*     Original Physical Range: [0...255] [] */
    /*     Variable-Name: aeIdfLstActErrFmyMon[0] */
    
    /* Destination-Signal Description: */
    /*     Name: EduPriv_PE_aeIdfLstActErrFmyMon0(intc_sigcv_tx_priv) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_U8, 8 bits, API */
    /*     Coded Range: [0x00...0xFF] */
    /*     Harmonized Physical Range: [0...255] [] */
    /*     Original Physical Range: [0...255] [] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_priv_Mapping_PE_aeIdfLstActErrFmyMon0 */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Conversion of 'aeIdfLstActErrFmyMon' to 'EduPriv_PE_aeIdfLstActErrFmyMon0' */
    /*lint -save -e734 */
	
	// Stub until ems2 is integrated
    bus_cpy = 1;//GET_aeIdfLstActErrFmyMon(0);
    /*lint -restore */
    /* Copy temporary-dst-container to DST */
    if(WRITE_SIGNAL_DATA_API(EduPriv_PE_aeIdfLstActErrFmyMon0, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduPriv_PE_aeIdfLstActErrFmyMon1
/*lint  -efile(451,ipl_hook_tx_priv_mcr.h) */
#include <ipl_hook_tx_priv_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduPriv_PE_aeIdfLstActErrFmyMon1) */
ICS_PL_RETURN_TYPE PL_Cvt_EduPriv_PE_aeIdfLstActErrFmyMon1(void)
{
    /* Conversion for TX-Bus-Signal 'EduPriv_PE_aeIdfLstActErrFmyMon1' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U8 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: aeIdfLstActErrFmyMon[8](intc_sigcv_tx_priv) */
    /*     Category, Type, Interface: NUM, ICS_PL_U8, VAR */
    /*     State(s): [0x0...0x0] */
    /*     Coded Range: [0x00...0xFF] */
    /*     Harmonized Physical Range: [0...255] [] */
    /*     Original Physical Range: [0...255] [] */
    /*     Variable-Name: aeIdfLstActErrFmyMon[1] */
    
    /* Destination-Signal Description: */
    /*     Name: EduPriv_PE_aeIdfLstActErrFmyMon1(intc_sigcv_tx_priv) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_U8, 8 bits, API */
    /*     Coded Range: [0x00...0xFF] */
    /*     Harmonized Physical Range: [0...255] [] */
    /*     Original Physical Range: [0...255] [] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_priv_Mapping_PE_aeIdfLstActErrFmyMon1 */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Conversion of 'aeIdfLstActErrFmyMon' to 'EduPriv_PE_aeIdfLstActErrFmyMon1' */
    /*lint -save -e734 */
	// Stub until ems2 is integrated
    bus_cpy = 1; //GET_aeIdfLstActErrFmyMon(1);
    /*lint -restore */
    /* Copy temporary-dst-container to DST */
    if(WRITE_SIGNAL_DATA_API(EduPriv_PE_aeIdfLstActErrFmyMon1, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduPriv_PE_aeIdfLstActErrFmyMon2
/*lint  -efile(451,ipl_hook_tx_priv_mcr.h) */
#include <ipl_hook_tx_priv_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduPriv_PE_aeIdfLstActErrFmyMon2) */
ICS_PL_RETURN_TYPE PL_Cvt_EduPriv_PE_aeIdfLstActErrFmyMon2(void)
{
    /* Conversion for TX-Bus-Signal 'EduPriv_PE_aeIdfLstActErrFmyMon2' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U8 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: aeIdfLstActErrFmyMon[8](intc_sigcv_tx_priv) */
    /*     Category, Type, Interface: NUM, ICS_PL_U8, VAR */
    /*     State(s): [0x0...0x0] */
    /*     Coded Range: [0x00...0xFF] */
    /*     Harmonized Physical Range: [0...255] [] */
    /*     Original Physical Range: [0...255] [] */
    /*     Variable-Name: aeIdfLstActErrFmyMon[2] */
    
    /* Destination-Signal Description: */
    /*     Name: EduPriv_PE_aeIdfLstActErrFmyMon2(intc_sigcv_tx_priv) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_U8, 8 bits, API */
    /*     Coded Range: [0x00...0xFF] */
    /*     Harmonized Physical Range: [0...255] [] */
    /*     Original Physical Range: [0...255] [] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_priv_Mapping_PE_aeIdfLstActErrFmyMon2 */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Conversion of 'aeIdfLstActErrFmyMon' to 'EduPriv_PE_aeIdfLstActErrFmyMon2' */
    /*lint -save -e734 */
	// Stub until ems2 is integrated
    bus_cpy = 1; //GET_aeIdfLstActErrFmyMon(2);
    /*lint -restore */
    /* Copy temporary-dst-container to DST */
    if(WRITE_SIGNAL_DATA_API(EduPriv_PE_aeIdfLstActErrFmyMon2, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduPriv_PE_aeIdfLstActErrFmyMon3
/*lint  -efile(451,ipl_hook_tx_priv_mcr.h) */
#include <ipl_hook_tx_priv_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduPriv_PE_aeIdfLstActErrFmyMon3) */
ICS_PL_RETURN_TYPE PL_Cvt_EduPriv_PE_aeIdfLstActErrFmyMon3(void)
{
    /* Conversion for TX-Bus-Signal 'EduPriv_PE_aeIdfLstActErrFmyMon3' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U8 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: aeIdfLstActErrFmyMon[8](intc_sigcv_tx_priv) */
    /*     Category, Type, Interface: NUM, ICS_PL_U8, VAR */
    /*     State(s): [0x0...0x0] */
    /*     Coded Range: [0x00...0xFF] */
    /*     Harmonized Physical Range: [0...255] [] */
    /*     Original Physical Range: [0...255] [] */
    /*     Variable-Name: aeIdfLstActErrFmyMon[3] */
    
    /* Destination-Signal Description: */
    /*     Name: EduPriv_PE_aeIdfLstActErrFmyMon3(intc_sigcv_tx_priv) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_U8, 8 bits, API */
    /*     Coded Range: [0x00...0xFF] */
    /*     Harmonized Physical Range: [0...255] [] */
    /*     Original Physical Range: [0...255] [] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_priv_Mapping_PE_aeIdfLstActErrFmyMon3 */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Conversion of 'aeIdfLstActErrFmyMon' to 'EduPriv_PE_aeIdfLstActErrFmyMon3' */
    /*lint -save -e734 */
	// Stub until ems2 is integrated
    bus_cpy = 1; //GET_aeIdfLstActErrFmyMon(3);
    /*lint -restore */
    /* Copy temporary-dst-container to DST */
    if(WRITE_SIGNAL_DATA_API(EduPriv_PE_aeIdfLstActErrFmyMon3, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduPriv_PE_aeIdfLstActErrFmyMon4
/*lint  -efile(451,ipl_hook_tx_priv_mcr.h) */
#include <ipl_hook_tx_priv_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduPriv_PE_aeIdfLstActErrFmyMon4) */
ICS_PL_RETURN_TYPE PL_Cvt_EduPriv_PE_aeIdfLstActErrFmyMon4(void)
{
    /* Conversion for TX-Bus-Signal 'EduPriv_PE_aeIdfLstActErrFmyMon4' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U8 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: aeIdfLstActErrFmyMon[8](intc_sigcv_tx_priv) */
    /*     Category, Type, Interface: NUM, ICS_PL_U8, VAR */
    /*     State(s): [0x0...0x0] */
    /*     Coded Range: [0x00...0xFF] */
    /*     Harmonized Physical Range: [0...255] [] */
    /*     Original Physical Range: [0...255] [] */
    /*     Variable-Name: aeIdfLstActErrFmyMon[4] */
    
    /* Destination-Signal Description: */
    /*     Name: EduPriv_PE_aeIdfLstActErrFmyMon4(intc_sigcv_tx_priv) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_U8, 8 bits, API */
    /*     Coded Range: [0x00...0xFF] */
    /*     Harmonized Physical Range: [0...255] [] */
    /*     Original Physical Range: [0...255] [] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_priv_Mapping_PE_aeIdfLstActErrFmyMon4 */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Conversion of 'aeIdfLstActErrFmyMon' to 'EduPriv_PE_aeIdfLstActErrFmyMon4' */
    /*lint -save -e734 */
	// Stub until ems2 is integrated
    bus_cpy = 1; //GET_aeIdfLstActErrFmyMon(4);
    /*lint -restore */
    /* Copy temporary-dst-container to DST */
    if(WRITE_SIGNAL_DATA_API(EduPriv_PE_aeIdfLstActErrFmyMon4, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduPriv_PE_aeIdfLstActErrFmyMon5
/*lint  -efile(451,ipl_hook_tx_priv_mcr.h) */
#include <ipl_hook_tx_priv_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduPriv_PE_aeIdfLstActErrFmyMon5) */
ICS_PL_RETURN_TYPE PL_Cvt_EduPriv_PE_aeIdfLstActErrFmyMon5(void)
{
    /* Conversion for TX-Bus-Signal 'EduPriv_PE_aeIdfLstActErrFmyMon5' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U8 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: aeIdfLstActErrFmyMon[8](intc_sigcv_tx_priv) */
    /*     Category, Type, Interface: NUM, ICS_PL_U8, VAR */
    /*     State(s): [0x0...0x0] */
    /*     Coded Range: [0x00...0xFF] */
    /*     Harmonized Physical Range: [0...255] [] */
    /*     Original Physical Range: [0...255] [] */
    /*     Variable-Name: aeIdfLstActErrFmyMon[5] */
    
    /* Destination-Signal Description: */
    /*     Name: EduPriv_PE_aeIdfLstActErrFmyMon5(intc_sigcv_tx_priv) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_U8, 8 bits, API */
    /*     Coded Range: [0x00...0xFF] */
    /*     Harmonized Physical Range: [0...255] [] */
    /*     Original Physical Range: [0...255] [] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_priv_Mapping_PE_aeIdfLstActErrFmyMon5 */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Conversion of 'aeIdfLstActErrFmyMon' to 'EduPriv_PE_aeIdfLstActErrFmyMon5' */
    /*lint -save -e734 */
	// Stub until ems2 is integrated
    bus_cpy = 1; //GET_aeIdfLstActErrFmyMon(5);
    /*lint -restore */
    /* Copy temporary-dst-container to DST */
    if(WRITE_SIGNAL_DATA_API(EduPriv_PE_aeIdfLstActErrFmyMon5, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduPriv_PE_aeIdfLstActErrFmyMon6
/*lint  -efile(451,ipl_hook_tx_priv_mcr.h) */
#include <ipl_hook_tx_priv_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduPriv_PE_aeIdfLstActErrFmyMon6) */
ICS_PL_RETURN_TYPE PL_Cvt_EduPriv_PE_aeIdfLstActErrFmyMon6(void)
{
    /* Conversion for TX-Bus-Signal 'EduPriv_PE_aeIdfLstActErrFmyMon6' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U8 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: aeIdfLstActErrFmyMon[8](intc_sigcv_tx_priv) */
    /*     Category, Type, Interface: NUM, ICS_PL_U8, VAR */
    /*     State(s): [0x0...0x0] */
    /*     Coded Range: [0x00...0xFF] */
    /*     Harmonized Physical Range: [0...255] [] */
    /*     Original Physical Range: [0...255] [] */
    /*     Variable-Name: aeIdfLstActErrFmyMon[6] */
    
    /* Destination-Signal Description: */
    /*     Name: EduPriv_PE_aeIdfLstActErrFmyMon6(intc_sigcv_tx_priv) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_U8, 8 bits, API */
    /*     Coded Range: [0x00...0xFF] */
    /*     Harmonized Physical Range: [0...255] [] */
    /*     Original Physical Range: [0...255] [] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_priv_Mapping_PE_aeIdfLstActErrFmyMon6 */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Conversion of 'aeIdfLstActErrFmyMon' to 'EduPriv_PE_aeIdfLstActErrFmyMon6' */
    /*lint -save -e734 */
	
	// Stub until ems2 is integrated
    bus_cpy = 1; //GET_aeIdfLstActErrFmyMon(6);
    /*lint -restore */
    /* Copy temporary-dst-container to DST */
    if(WRITE_SIGNAL_DATA_API(EduPriv_PE_aeIdfLstActErrFmyMon6, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
#undef ACTION_ID
#define ACTION_ID ACTION_ID_PL_Cvt_EduPriv_PE_aeIdfLstActErrFmyMon7
/*lint  -efile(451,ipl_hook_tx_priv_mcr.h) */
#include <ipl_hook_tx_priv_mcr.h>
#define  MEM_CODE            ICS_PL_MEM_CODE_SERVICE
#include <gmem.h>
/*lint  -efunc(774,PL_Cvt_EduPriv_PE_aeIdfLstActErrFmyMon7) */
ICS_PL_RETURN_TYPE PL_Cvt_EduPriv_PE_aeIdfLstActErrFmyMon7(void)
{
    /* Conversion for TX-Bus-Signal 'EduPriv_PE_aeIdfLstActErrFmyMon7' */
    
    /* Allocate temporary variables */
    ICS_PL_RETURN_TYPE tmp_return_value = ICS_PL_TRUE;
    ICS_PL_U8 bus_cpy;
    
    
    /* Source-Signal Description: */
    /*     Name: aeIdfLstActErrFmyMon[8](intc_sigcv_tx_priv) */
    /*     Category, Type, Interface: NUM, ICS_PL_U8, VAR */
    /*     State(s): [0x0...0x0] */
    /*     Coded Range: [0x00...0xFF] */
    /*     Harmonized Physical Range: [0...255] [] */
    /*     Original Physical Range: [0...255] [] */
    /*     Variable-Name: aeIdfLstActErrFmyMon[7] */
    
    /* Destination-Signal Description: */
    /*     Name: EduPriv_PE_aeIdfLstActErrFmyMon7(intc_sigcv_tx_priv) */
    /*     Category, Type, length, Interface: NUM, ICS_PL_U8, 8 bits, API */
    /*     Coded Range: [0x00...0xFF] */
    /*     Harmonized Physical Range: [0...255] [] */
    /*     Original Physical Range: [0...255] [] */
    
    /* Mapping Description: */
    /*     ID: intc_sigcv_tx_priv_Mapping_PE_aeIdfLstActErrFmyMon7 */
    /*     Processing: UNCONDITIONAL */
    /*     Limit-Handling: automatically limit Dst-Signal */
    /*     Conversion-Handling: Internal conversion */
    /*     Out-Off-Range-Handling: Cancel conversion if Src-Signal is out of valid range */
    
    /* Copy SRC to temporary-src-container */
    
    /* Conversion of 'aeIdfLstActErrFmyMon' to 'EduPriv_PE_aeIdfLstActErrFmyMon7' */
    /*lint -save -e734 */
	
    // Stub until ems2 is integrated
	
    bus_cpy = 1; //GET_aeIdfLstActErrFmyMon(7);
    /*lint -restore */
    /* Copy temporary-dst-container to DST */
    if(WRITE_SIGNAL_DATA_API(EduPriv_PE_aeIdfLstActErrFmyMon7, &bus_cpy) != WRITE_SIGNAL_DATA_API_SUCCESS)
    {
        tmp_return_value = ICS_PL_FALSE;
    }
    else
    {
        /* Nothing to do here */
    }
    
    return tmp_return_value;
}
